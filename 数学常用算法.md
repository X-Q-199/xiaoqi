# 数学常用算法

## 第二类斯特林数

- 题目：[F-鸡数题！_2024牛客寒假算法基础集训营1 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/67741/F)
- 定义：将n个不同的数分在m个集合方案数，保证集合不为空且不区分顺序。
- 递推式：S(n,k)=S(n-1,k-1)+k*S(n-1,k)
- 通项式：<img src="D:\markdown\第二类斯特林数通项式.png" alt="第二类斯特林数通项式" style="zoom: 50%;" />
- [斯特林数 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/math/combinatorics/stirling/)
- 代码实现：

```
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define LL long long
#define DB double
#define IOS ios::sync_with_stdio(0)
const LL INF=0x7fffffff;
const LL LLF=0x7fffffffffffffff;
const LL LLF_MID=0x7f7f7f7f7f7f7f7f;
const LL MOD=1e9+7;
LL fact[100000+5],invfact[100000+5];
LL ksm(LL n,LL k);
void solve();
int main(void){
	IOS;
	cin.tie(0);cout.tie(0);
	LL t;
// 	cin>>t;
	t=1;
	while(t--){
		solve();
	}
}
void solve(){
	LL n,m;
    cin>>n>>m;
    invfact[0]=1;
    fact[1]=invfact[1]=1;
    for(LL i=2;i<=100002;++i){
        invfact[i]=(MOD-MOD/i)*invfact[MOD%i]%MOD;
    }
    for(LL i=2;i<=100002;++i){
        invfact[i]=invfact[i]*invfact[i-1]%MOD;
        fact[i]=i*fact[i-1]%MOD;
    }
    LL ans=0;
    for(LL i=0;i<=m;++i){
        LL k=1;
        if(i&1) k=-1;
        ans=(ans+k*ksm(m-i,n)*fact[m]%MOD*invfact[i]%MOD*invfact[m-i]%MOD)%MOD;
        if(i&1) ans=(ans+MOD)%MOD;
    }
    ans=ans*invfact[m]%MOD;
    cout<<ans<<endl;
}
LL ksm(LL n,LL m){
    LL ans=1;
    while(m){
        if(m&1) ans=ans*n%MOD;
        n=n*n%MOD;
        m>>=1;
    }
    return ans;
}
```

## 第一类斯特林数

- 定义：将n个不同的元素分成k个的轮回集合方案数，保证轮回不为空且不区分顺序。
- 递推式：S{n,k}=S{n-1,k-1}+(n-1)*S{n-1,k}
- [斯特林数 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/math/combinatorics/stirling/)

## 错位排列

- 定义：数列的第n个位置上的数不为n的数列方案数。
- [错位排列 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/math/combinatorics/derangement/)

## 两集合元素差值绝对值最大化

- 题目：[Problem - D - Codeforces](https://codeforces.com/contest/1921/problem/D)
- 代码实现：

```
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define LL long long
#define DB double
#define IOS ios::sync_with_stdio(0)
const LL INF=0x7fffffff;
const LL LLF=0x7fffffffffffffff;
const LL LLF_MID=0x7f7f7f7f7f7f7f7f;
const LL MOD=998244353;
LL a[200005],b[200005];
void solve();
int main(void){
	IOS;
	cin.tie(0);cout.tie(0);
	LL t;
	cin>>t;
//	t=1;
	while(t--){
		solve();
	}
}
void solve(){
	LL an,bn;
	cin>>an>>bn;
	for(LL i=1;i<=an;++i){
		cin>>a[i];
	}
	for(LL i=1;i<=bn;++i){
		cin>>b[i];
	}
	sort(a+1,a+an+1);
	sort(b+1,b+bn+1);
	LL l=1,r=an,u=1,v=bn;
	LL ans=0;
	while(l<=r){
		LL data1=abs(a[l]-b[v]);
		LL data2=abs(a[r]-b[u]);
		ans+=data1>data2?data1:data2;
		if(data1>data2){
			++l;
			--v;
		}else{
			--r;
			++u;
		}
	}
	cout<<ans<<endl;
}
```

## 两点移动过程距离最小化

- 题目：[J-又鸟之亦心_2024牛客寒假算法基础集训营1 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/67741/J)
- 代码实现：

```
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define LL long long
#define DB double
#define IOS ios::sync_with_stdio(0)
const LL INF=0x7fffffff;
const LL LLF=0x7fffffffffffffff;
const LL LLF_MID=0x7f7f7f7f7f7f7f7f;
const LL MOD=998244353;
LL d[100005];
void solve();
int main(void){
	IOS;
	cin.tie(0);cout.tie(0);
	LL t;
// 	cin>>t;
	t=1;
	while(t--){
		solve();
	}
}
void solve(){
	LL n,x,y;
    cin>>n>>x>>y;
    for(LL i=1;i<=n;++i){
        cin>>d[i];
    }
    LL l=1,r=1e9;
    while(l<r){
        LL mid=l+r>>1;
        bool flag=true;
        set<LL> s;
        if(abs(x-y)<=mid){
            LL y2=y;
            s.insert(x);
            for(LL i=1;i<=n;++i){
                if(abs(y2-d[i])<=mid){
                    s.insert(y2);
                }
                while(s.size()&&(*s.begin())<d[i]-mid){
                    s.erase(s.begin());
                }
                while(s.size()&&(*s.rbegin())>d[i]+mid){
                    s.erase(*s.rbegin());
                }
                if(!s.size()){
                    flag=false;
                    break;
                }
                y2=d[i];
            }
        }else{
            flag=false;
        }
        if(flag){
            r=mid;
        }else{
            l=mid+1;
        }
    }
    cout<<l<<endl;
}
```

## 将n个相同的元素分成m个不相同不为空集合方案数

- 题目：[F-小红的连续段_牛客周赛 Round 31 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/74362/F)

- 代码实现：

```
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define LL long long
#define DB double
#define IOS ios::sync_with_stdio(0)
const LL INF=0x7fffffff;
const LL LLF=0x7fffffffffffffff;
const LL LLF_MID=0x7f7f7f7f7f7f7f7f;
const LL MOD=1e9+7;
LL dp[1005][1005];
void init();
void solve();
int main(void){
	IOS;
	cin.tie(0);cout.tie(0);
    init();
	LL t;
// 	cin>>t;
	t=1;
	while(t--){
		solve();
	}
}
void solve(){
    LL x,y;
    cin>>x>>y;
    for(LL i=1;i<=x+y;++i){
        LL data=(i>>1);
        LL data2=(i>>1)+(i&1);
        cout<<(dp[x][data]*dp[y][data2]%MOD+dp[x][data2]*dp[y][data]%MOD)%MOD<<endl;
    }
}
void init(){
    for(LL i=1;i<1002;++i){
        for(LL j=1;j<=i;++j){
            if(j==1) dp[i][j]=1;
            else dp[i][j]=(dp[i-1][j-1]+dp[i-1][j])%MOD;
        }
    }
}
```

## 对某区间上数进行左操作、右操作或者不操作使得区间被包含的最小值

- 题目：[Problem - G - Codeforces](https://codeforces.com/contest/1927/problem/G)

- 代码实现：

```
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define LL long long
#define DB double
#define IOS ios::sync_with_stdio(0)
const LL INF=0x7fffffff;
const LL LLF=0x3fffffffffffffff;
const LL LLF_MID=0x7f7f7f7f7f7f7f7f;
const LL MOD=998244353;
LL d[200005];
void solve();
int main(void){
	IOS;
	cin.tie(0);cout.tie(0);
	LL t;
	cin>>t;
//	t=1;
	while(t--){
		solve();
	}
}
void solve(){
	LL n;
	cin>>n;
	for(LL i=1;i<=n;++i){
		cin>>d[i];
	}
	vector<vector<LL>> dp(n+2,vector<LL>(n+2,LLF));
	dp[0][0]=0;
	for(LL i=1;i<=n;++i){
		for(LL j=0;j<=n;++j){
			dp[i][j]=dp[i-1][j];
		}
		for(LL j=0;j<i;++j){
			LL mx=i;
			for(LL k=i-1;k>=max(i-d[i],0ll);--k){
				dp[i][i]=min(dp[i][i],dp[j][k]+1);
				if(k>j) mx=max(mx,min(n,k+d[k]-1));
				dp[i][mx]=min(dp[i][mx],dp[j][k]+2);
			}
		}
		LL k=i+d[i]-1;
		k=min(n,k);
		for(LL j=i-1;j<k;++j){
			dp[i][k]=min(dp[i][k],dp[i-1][j]+1);
		}
		for(LL j=n-1;j;--j){
			dp[i][j]=min(dp[i][j],dp[i][j+1]);
		}
	}
	cout<<dp[n][n]<<endl;
}
```

## 对数组中相同的数进行批量修改

- 题目：[E-多重映射_牛客小白月赛88 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/75771/E)
- 代码实现：

```
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define endl '\n'
#define DB double
void solve();
int main(void){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	LL t;
	cin>>t;
//	t=1;
	while(t--){
		solve();
	}
}
void solve(){
	LL n,k;
    cin>>n>>k;
    vector<LL> vec(n),vec1(k),vec2(k);
    map<LL,LL> mp;
    for(LL i=0;i<n;++i){
        cin>>vec[i];
        mp[vec[i]]=vec[i];
    }
    for(LL i=0;i<k;++i){
        cin>>vec1[i]>>vec2[i];
        mp[vec1[i]]=vec1[i];
        mp[vec2[i]]=vec2[i];
    }
    for(LL i=k-1;~i;--i){
        mp[vec1[i]]=mp[vec2[i]];
    }
    for(LL i=0;i<n;++i){
        cout<<mp[vec[i]]<<" ";
    }
    cout<<endl;
}
```

## 求两集合中各选一数求和所得数不比某一值大的对数最大值

- 题目：[H-卷王_第十一届"图灵杯"NEUQ-ACM程序设计竞赛 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/76681/H)
- 代码实现：

```
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define LL long long
#define DB double
#define IOS ios::sync_with_stdio(0)
const LL INF=0x7fffffff;
const LL LLF=0x7fffffffffffffff;
const LL LLF_MID=0x7f7f7f7f7f7f7f7f;
const LL MOD=998244353;
LL d[200005],d2[200005];
void solve();
int main(void){
	IOS;
	cin.tie(0);cout.tie(0);
	LL t;
// 	cin>>t;
	t=1;
	while(t--){
		solve();
	}
}
void solve(){
    LL n,k;
    cin>>n>>k;
    for(LL i=0;i<n;++i){
        cin>>d[i];
    }
    for(LL i=0;i<n;++i){
        cin>>d2[i];
    }
    LL he=d[k-1]+d2[0];
    for(LL i=k-1;i;--i){
        d[i]=d[i-1];
    }
    LL ans=0;
    for(LL i=n-1,k=1;i;--i){
        while(d[i]+d2[k]>he&&k!=n){
            ++k;
        }
        if(k==n){
            break;
        }
        ++ans;
        ++k;
    }
    cout<<n-ans<<endl;
}
```

## 莫比乌斯反演

