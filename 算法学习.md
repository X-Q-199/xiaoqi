# 算法学习

## STL的简单运用

### set

集合中不存在重复的元素。头文件导入方式"#include<set>",对象定义方式为"set<LL> s"。

基础方法：

```
s.begin()	返回set容器的第一个元素的地址（迭代器）
s.end()	返回set容器的最后一个元素的下一个地址（迭代器）
s.rbegin()	返回逆序迭代器，指向容器元素最后一个位置
s.rend()	返回逆序迭代器，指向容器第一个元素前面的位置
s.clear()	删除set容器中的所有的元素
s.empty()	判断set容器是否为空
s.insert()	插入一个元素
s.size()	返回当前set容器中的元素个数
erase(iterator)	删除定位器iterator指向的值
erase(key_value)	删除键值key_value的值
s.find(element)	查找set中的某一元素，有则返回该元素对应的迭代器，无则返回结束迭代器
s.count(element)	查找set中的元素出现的个数，由于set中元素唯一，此函数相当于查询element是否出现
s.lower_bound(k)	返回大于等于k的第一个元素的迭代器
s.upper_bound(k)	返回大于k的第一个元素的迭代器
```

### map

映射键值中键不可重复，而值可重复。头文件导入方式"#include<map>"，对象定义方式为"map<LL,LL> mp"。

基础方法：

```
mp.find(key)	返回键为key的映射的迭代器 当数据存在时，返回数据所在位置的迭代器，数据不存在时，返回mp.end()
mp.erase(it)	删除迭代器对应的键和值
mp.erase(key)	根据映射的键删除键和值
mp.size()	返回映射的对数
mp.clear()	清空map中的所有元素
mp.insert()	插入元素，插入时要构造键值对
mp.empty()	如果map为空，返回true，否则返回false
mp.begin()	返回指向map第一个元素的迭代器（地址）
mp.end()	返回指向map尾部的迭代器（最后一个元素的下一个地址）
mp.rbegin()	返回指向map最后一个元素的迭代器（地址）
mp.rend()	返回指向map第一个元素前面(上一个）的逆向迭代器（地址）
mp.count(key)	查看元素是否存在，因为map中键是唯一的，所以存在返回1，不存在返回0
mp.lower_bound()	返回一个迭代器，指向键值>= key的第一个元素
mp.upper_bound()	返回一个迭代器，指向键值> key的第一个元素
mp[key]=value  此语句可直接插入或者修改键值对
```

### queue

队列的基本特点是先进先出，后进后出。头文件导入方式"#include<queue>", 对象定义方式为"queue<LL> q“。

基础方法：

```
q.front()	返回队首元素
q.back()	返回队尾元素
q.push(element)	尾部添加一个元素element 进队
q.pop()	删除第一个元素 出队
q.size()	返回队列中元素个数，返回值类型unsigned int
q.empty()	判断是否为空，队列为空，返回true
注意没有clear()！    不提供该方法
```

### stack

栈的基本特点是先进先出，后进后出。头文件的导入方式为"#include<stack>", 对象定义方式为"stack<LL> s"。

基础方法：

```
s.push(ele)	元素ele入栈，增加元素
s.pop()	移除栈顶元素
s.top()	取得栈顶元素（但不删除）
s.empty()	检测栈内是否为空，空为真
s.size()	返回栈内元素的个数
注意没有clear()！    不提供该方法
```

### vector

动态数组的特点是数组大小可以动态变化。头文件导入方式为"#include <vector>",对象定义方式为"vector<LL> vec"。

基础方法：

```
vec.front()	返回第一个数据
vec.back()	返回数组中的最后一个数据
vec.pop_back()	删除最后一个数据
vec.push_back(element)	在尾部加一个数据
vec.size()	返回实际数据个数（unsigned类型）
vec.clear()	清除元素个数，N为元素个数
vec.erase(it)  删除定位器iterator指向的位置
vec.resize(n, v)	改变数组大小为n,n个空间数值赋为v，如果没有默认赋值为0
vec.insert(it, x)	向任意迭代器it插入一个元素x
例：vec.insert(vec.begin() + 2,-1)	将-1插入vec[2]的位置
vec.begin()	返回首元素的迭代器（通俗来说就是地址
vec.end()	返回最后一个元素后一个位置的迭代器（地址）
vec.empty()	判断是否为空，为空返回真，反之返回假
vec[index] 可以使用下标进行访问
```

### priority_queue

优先队列的特点是容器中的元素有序。头文件导入方式为"#include<queue>"，对象定义方式为"priority_queue<LL> q"。

基础方法：

```
q.top()	    访问队首元素
q.push()	入队
q.pop()	    堆顶（队首）元素出队
q.size()	队列元素个数
q.empty()	是否为空
注意没有clear()！    不提供该方法
priority_queue<int> q;   默认大根堆, 即每次取出的元素是队列中的最大值
priority_queue<int, vector<int>, greater<int>()> q;   小根堆, 每次取出的元素是队列中的最小值
```

### iterator迭代器的使用

```
1) 正向迭代器，定义方法如下：
容器类名::iterator  迭代器名;

2) 常量正向迭代器，定义方法如下：
容器类名::const_iterator  迭代器名;

3) 反向迭代器，定义方法如下：
容器类名::reverse_iterator  迭代器名;

4) 常量反向迭代器，定义方法如下：
容器类名::const_reverse_iterator  迭代器名;

注意：迭代器都可以进行++操作。反向迭代器和正向迭代器的区别在于：
对正向迭代器进行++操作时，迭代器会指向容器中的后一个元素；
而对反向迭代器进行++操作时，迭代器会指向容器中的前一个元素。

例：
for(set<int>::iterator it = s.begin(); it != s.end(); it++)
	cout << *it << " ";
```

### 增强for循环搭配智能指针使用

```
for(auto i : s)
	cout << i << endl;
```

### 集合运算符重载方式

```
struct cmp {
    bool operator () (const int& u, const int& v) const {
       return u > v;
    }
};
set<int, cmp> s; 
set<int> s; // 默认从小到大排序
set<int, greater<int>()> s; // 从大到小排序
```



## 基础数论知识

### 合数与素数

合数是指在大于1的整数中除了能被1和本身整除外，还能被其他数（0除外）整除的数。质（素）数是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。

### 整除

若整数b除以非零整数a，商为整数，且余数为零， 我们就说b能被a整除（或说a能整除b），b为被除数，a为除数，即a|b（“|”是整除符号），读作“a整除b”或“b能被a整除”。a叫做b的约数（或因数），b叫做a的倍数。整除属于除尽的一种特殊情况。

### 互质

互质是公约数只有1的两个整数，叫做互质整数。

### 同余

数论中的重要概念。给定一个正整数m，如果两个整数a和b满足a-b能够被m整除，即(a-b)/m得到一个整数，那么就称整数a与b对模m同余，记作a≡b(mod m)。对模m同余是整数的一个等价关系。

### 欧拉函数

定义：小于n的正整数中与n互质的数的数目。

```
int euler(int x){
	int res=x,a=x;
	for(int i=2;i*i<=a;i++){
		if(a%i ==  0){
			res=res/i*(i-1);
			while(a%i == 0) a=a/i;
		}
	}
	if(a>1) res=res/a*(a-1);
	return res;
}
```

### 欧几里得算法

```
int gcd(int a , int b){
     return a%b==0? b:gcd(b,a%b);
}//其中a的值应大于等于b的值
```

### 扩展欧几里得算法

若有ax+by=1,当a与b互质时，该方程有解，所得一个特解（x~0~，y~0~），可求得该方程的通解为{ (x，y）| x=x~0~+bt，y=y~0~-at }。

```
void extend_gcd(int a,int b,int &x,int &y){
	if(b==0){
        x=1;
        y=0;
        return;
	}
	extend_gcd(b,a%b,x,y);
	int tmp=x;
	x=y;
	y=tmp-a/b*y;
}
```

### 费马小定理

若p为质数且gcd(a,p)=1或者说p为质数a不为p的倍数时，那么就有：a<sup>p-1</sup> ≡ 1 (mod p)。

利用费马小定理实现降幂：a<sup>k</sup> ≡ a<sup>k mod (p-1)</sup> (mod p)。

### 欧拉定理

∀a,m，若gcd(a,m)=1，则有：a<sup>φ(m)</sup> ≡ 1 (mod m)。

### 欧拉降幂

若a和m互质 a<sup>k</sup> ≡ a <sup>k mod φ(m)</sup> (mod m)。

若a和m不互质 a<sup>k</sup> ≡ a <sup>k mod φ(m) + φ(m)</sup> (mod m)。

### 欧拉筛

```
bool judge[1e6+5]; //筛除标记
vector<int> primes; //存放素数的不定长数组
memset(judge,true,sizeof(judge));
judge[0]=false;
judge[1]=false;// 0和1都不是素数
for(int i=2;i<1e6+2;i++){
    if(judge[i]){
    	primes.push_back(i);
    	cnt++;//记录素数个数
   	}
  	for(int j=0;j<cnt;j++){
   		if(i*primes[j]>=1e6+2) break;
   		judge[i*primes[j]]=false; //筛除
   		if(i%primes[j]==0) break; //关键代码
   	}
}
vector<int>::iterator it;
for(it=primes.begin();it!=primes.end();it++) printf("%d\n",*it); //遍历
```

### 快速幂

```
LL pow(LL a,LL b,LL m){
    a%=m;
    LL ans=1;
    while(b){
        if(b&1) ans=ans*a%m;
        a=a*a%m;
        b>>=1;
    }
    return ans;
}
```

### 逆元

逆元的定义：
当 ax ≡ 1(mod b)， x即为 a 在mod b 意义下的逆元。
逆元的数学符号是 inv ，a 在mod b 意义下的逆元记作 inv(a,b)。注意不要写反了。
简单来说逆元就是在mod某个数意义下的倒数例如5x ≡ 1（mod 3）x=2是满足10 = 1（mod3）所以称2是5在mod3意义下的逆元。这里需要特别注意只有a和b互质，a才有关于b的逆元。

那么逆元有什么用呢？
(a + b) % p = (a%p + b%p) %p （对）
(a - b) % p = (a%p - b%p) %p （对）
(a * b) % p = (a%p * b%p) %p （对）
(a / b) % p = (a%p / b%p) %p （错）
在求余的过程中我们发现只有除法是不能分开运算的，而当a过大时，在计算除法过程中可能会造成比较大的精度损失，所以对于这种情况我们一般会把式子转换成那么(a / b) % p = (a * inv(b) ) % p = (a % p * inv(b) % p) % p来进行计算。这样就解决了除法不能分开计算的问题。

费马小定理求逆元：

```
LL pow(LL a,LL b,LL m){
    a%=m;
    LL ans=1;
    while(b>0){
        if(b&1) ans=ans*a%m;
        a=a*a%m;
        b>>=1;
    }
    return ans;
}
LL fm(LL a, LL b){//费马求a关于b的逆元 
        return pow(a, b-2, b);
}
```

递归求逆元：

```
LL inv(LL i){
    if(i==1) return 1;
    return (mod-mod/i)*inv(mod%i)%mod;
}
```

递推求逆元：

```
void getInv(LL mod){
	LL inv[mod+5];
	memset(inv,0,sizeof inv);
    inv[1]=1;
    for(int i=2;i<mod;i++)
        inv[i]=(mod-mod/i)*inv[mod%i]%mod;
}
```

### 常见符号

- MOD
  mod意为模意义下结果一定为正
  %是一种运算，结果可以为负

- 同余符号（≡）

  两个整数a，b，如果a mod m = b mod m则称a，b对于模m同余
  记作a ≡ b ( mod m )

- 求和符号sigma（Σ ）

- 求积符号Π

- 同余≡

  记作 a ≡ b (mod m) 　读作a同余于b模m，或读作a与b关于模m同余

- 整除|

  x|y，表示x整除y，即x是y的因数

- gcd（x，y）
  代表x和y的最大公约数，也可写作（x，y）

- lcm（x，y）
  代表x和y的最小公倍数，也可写作[X,Y]



## 基础算法

### 1、搜索技术

#### BFS与DFS

- 题目

​		推箱子是一款经典游戏。这里我们玩的是一个简单版本,就是在一个N*M的地图上，有1个玩家、1个箱子、1个目的地以及若干障碍，其余是空地。玩家可以往上下左右4个方向移动，但是不能移动出地图或者移动到障碍里去。如果往这个方向移动推到了箱子，箱子也会按这个方向移动一格，当然，箱子也不能被推出地图或推到障碍里。当箱子被推到目的地以后，游戏目标达成。现在告诉你游戏开始是初始的地图布局，要求用深度优先搜索找到游戏的解（注意这里不保证步数最少）。玩家每到一个格子，就按上(U)，右(R)，下(D)，左(L)顺时针方向尝试，每一个方向都都在前一个方向失败时才可能尝试。

- 输入

​		第一行输入两个数字N，M表示地图的大小。其中0<N，M<=12。
​		接下来有N行，每行包含M个字符表示游戏地图。其中 . 表示空地、X表示玩家、*表示箱子、#表示障碍、@表示目的地。

- 输出

​		有解时，输出玩家走的每一步。当无论如何达成不了的时候，输出-1。

- 样例输入

```
6 6
...#..
......
#*##..
..##.#
..X...
.@#...
```

- 样例输出

```
RRUUULLULDDUURDRRURDDLDDRDLLULLUUDDRRRUUULLULLDRRRLULDDDDRRRUURUULDDDUULLULDDDDRRDRRULLLRRUUULLULDDDD
```

- 代码实现

```
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
int m,n;
int dir[4][2]={{-1,0},{0,1},{1,0},{0,-1}};
char dir1[4]={'U','R','D','L'};
char map1[15][15];
bool map_lujin[15][15][15][15];
bool map_lujin1[15][15][4];
int x3,y3;
struct node_tuixiangzi{
	int x,y,x1,y1,x2,y2;
	string str;
};
bool bfs_box(node_tuixiangzi); 
bool bfs_ren(node_tuixiangzi);
string dfs_lujin(node_tuixiangzi &a);
int main(void){
	cin>>n>>m;
	node_tuixiangzi a{0};
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			cin>>map1[i][j];
			if(map1[i][j]=='*'){
				a.x1=i;
				a.y1=j;
				map1[i][j]='.';
			}else if(map1[i][j]=='@'){
				a.x2=i;
				a.y2=j;
				map1[i][j]='.';
			}else if(map1[i][j]=='X'){
				a.x=i;
				a.y=j;
				map1[i][j]='.';
			}
		}
	}
	if(!bfs_box(a)){
		cout<<"-1"<<endl;
		return 0;
	}
	cout<<dfs_lujin(a)<<endl;
}
string dfs_lujin(node_tuixiangzi &a){
	if(a.x1==a.x2&&a.y1==a.y2) return a.str;
	if(a.x1==1&&a.x2!=1||a.x1==n&&a.x2!=n||a.y1==1&&a.y2!=1||a.y1==m&&a.y2!=m) return "-1";
	for(int i=0;i<=3;++i){
		int x=a.x+dir[i][0],y=a.y+dir[i][1];
		if(x>n||x<1||y>m||y<1||map1[x][y]=='#') continue;
		int x1=dir[i][0]+a.x1,y1=dir[i][1]+a.y1;
		if(x==a.x1&&y==a.y1&&(x1>n||x1<1||y1>m||y1<1||map1[x1][y1]=='#'||map_lujin[x][y][x1][y1])) continue;
		if((x!=a.x1||y!=a.y1)&&map_lujin[x][y][a.x1][a.y1]) continue;
		a.x=x;
		a.y=y;
		if(a.x==a.x1&&a.y==a.y1){
			a.x1=x1;
			a.y1=y1;
		}
		map_lujin[a.x][a.y][a.x1][a.y1]=1;
		a.str+=dir1[i];
		string str=dfs_lujin(a);
		if(str!="-1") return str;
		map_lujin[a.x][a.y][a.x1][a.y1]=0;
		a.x-=dir[i][0];
		a.y-=dir[i][1];
		if(a.x1==x1&&a.y1==y1){
			a.x1-=dir[i][0];
			a.y1-=dir[i][1];
		}
		a.str=a.str.substr(0,a.str.size()-1);
	}
	return "-1";
}
bool bfs_box(node_tuixiangzi a){
	queue<node_tuixiangzi> que;
	que.push(a);
	while(que.size()){
		node_tuixiangzi b=que.front();
		que.pop();
		for(int i=0;i<=3;++i){
			int x0=b.x1+dir[i][0],y0=b.y1+dir[i][1];
			if(x0<=n&&x0>=1&&y0>=1&&y0<=m&&map1[x0][y0]!='#'&&!map_lujin1[b.x1][b.y1][i]){
				x3=b.x1-dir[i][0];
				y3=b.y1-dir[i][1];
				if(x3<=n&&x3>=1&&y3>=1&&y3<=m&&map1[x3][y3]!='#'){
					if(bfs_ren(b)){
						node_tuixiangzi c=b;
						map_lujin1[c.x1][c.y1][i]=1;
						c.x=c.x1;
						c.y=c.y1;
						c.x1=x0;
						c.y1=y0;
						if(c.x1==c.x2&&c.y1==c.y2) return 1;
						que.push(c);
					}
				}
			}
		}
	}
	return 0;
}
bool bfs_ren(node_tuixiangzi a){
	if(a.x==x3&&a.y==y3) return 1;
	queue<node_tuixiangzi> que;
	que.push(a);
	bool map[15][15]={0};
	map[a.x][a.y]=1;
	while(que.size()){
		node_tuixiangzi b=que.front();
		que.pop();
		for(int i=0;i<=3;++i){
			int x0=b.x+dir[i][0],y0=b.y+dir[i][1];
			if(x0<=n&&x0>=1&&y0>=1&&y0<=m&&map1[x0][y0]=='.'&&!map[x0][y0]){
				node_tuixiangzi c=b;
				map[x0][y0]=1;
				c.x=x0;
				c.y=y0;
				if(c.x==x3&&c.y==y3) return 1;
				que.push(c);
			}
		}
	}
	return 0;
}
```



### 2、高级数据结构

#### 并查集

- 题目

​		给定一棵 n 个节点的无根树，其中边权只有 1 或 2 两种。
​		现在定义 u→v 两点之间的距离 w(u,v) 为两点间简单路径上所有边权的最大公约数。令 f(t) 表示为节点 t 到树上其他节点的距离之和。
​		求 min⁡(f(1),f(2),…,f(n))。

- 输入

​		第一行包含一个正整数 n，代表这棵树的节点数量。(1≤n≤10^5^)
​		接下来 n−1行，每行三个正整数 u,v,w，代表 u 和 v 之间有一条权值为 w 的无向边。(1≤u,v≤n,1≤w≤2)

- 输出

​		输出一行一个正整数，代表min⁡(f(1),f(2),f(3)…f(n))。

- 样例输入

```
5
1 2 2
2 3 2
1 4 1
4 5 2
```

- 样例输出

```
5
```

- 代码实现

```
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define endl '\n'
#define IOS ios::sync_with_stdio(0)
const int INF=0x7fffffff;
const LL LLF=0x7fffffffffffffff;
const LL MOD=1000000007;
LL zhi[100005],count1[100005];
LL find(LL n);
void join(LL a,LL b);
void init(LL n);
int main(void){
    IOS;
    cin.tie(0);cout.tie(0);
    LL n;
    cin>>n;
    init(n);
    for(LL i=1;i<=n;++i){
        LL a,b,c;
        cin>>a>>b>>c;
        if(c==2){
            join(a,b);
        }
    }
    LL ans=n;
    for(LL i=1;i<=n;++i){
        ans=min(count1[find(i)],ans);
    }
    cout<<2*(ans-1)+(n-ans)<<endl;
}
LL find(LL n){
    if(zhi[n]!=n) zhi[n]=find(zhi[n]);
    return zhi[n];
}
void join(LL a,LL b){
    LL x=find(a),y=find(b);
    if(x!=y){
        zhi[x]=y;
        count1[y]+=count1[x];
    }
}
void init(LL n){
    for(LL i=1;i<=n;++i){
        zhi[i]=i;
        count1[i]=1;
    }
}
```



#### 平衡二叉树

- 代码实现：

```
#include<bits/stdc++.h>
using namespace std;
struct tree{
  int val;
  int hei;
  tree *l,*r;
  tree(int val): val(val),hei(1),l(0),r(0) {}
};
int getHeight(tree *node){
  if(!node) return 0;
  return node->hei;
}
void updataHeight(tree *node){
  node->hei = max(getHeight(node->l),getHeight(node->r)) + 1;
}
int balance(tree *node){
  return getHeight(node->l) - getHeight(node->r);
}
tree *r(tree *root){
  tree *node = root->l;
  node->l = node->r;
  node->r = root;
  updataHeight(root);
  updataHeight(node);
  return node;
}
tree *l(tree *root){
  tree *node = root->r;
  root->r = node->l;
  node->l = root;
  updataHeight(root);
  updataHeight(node);
  return node;
}
tree *rl(tree *root){
  root->r = r(root->r);
  return l(root);
}
tree *lr(tree *root){
  root->l = l(root->l);
  return r(root);
}
tree *insertNode(tree *root,int val){
  if(!root){
    root = new tree(val);
    return root;
  }
  if(root->val > val){
    root->l = insertNode(root->l,val);
    updataHeight(root);
    if(balance(root) == 2){
      if(balance(root->l) == 1){
        root = r(root);
      }else if(balance(root->l) == -1){
        root = lr(root);
      }
    }
  }else if(root->val <val){
    root->r = insertNode(root->r,val);
    updataHeight(root);
    if(balance(root) == -2){
      if(balance(root->r) == -1){
        root = l(root);
      }else if(balance(root->r) == 1){
        root = rl(root);
      }
    }
  }
  return root;
}
bool findNode(tree *root,int val){
  if(!root) return 0;
  if(root->val == val) return 1;
  else if(root->val > val) return findNode(root->l,val);
  else return findNode(root->r,val);
}
int main(void){
  int n,m;
  cin>>n>>m;
  tree *root = 0;
  for(int i = 1; i <= n; ++i){
    int val;
    cin>>val;
    root = insertNode(root,val);
  }
  for(int i = 1; i <= m; ++i){
    int val;
    cin>>val;
    cout<<findNode(root,val) ? 1 : 0;
    cout<<'\n';
  }
}
```



#### 线段树

- 题目

​		有编号是1~n的n个数字2≤n≤8000，乱序排列，顺序是未知的。对于每个位置的数字，知道排在它前面比它小的数字有多少个。求这个乱序数列的顺序。

- 输入

​		第一行输入数n。
​		第二行输入n个数。

- 输出

​		输出乱序数列的顺序。

- 样例输入

```
5
0 1 2 1 0
```

- 样例输出

```
2 4 5 3 1
```

- 代码实现

```
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define LL long long
#define IOS ios::sync_with_stdio(0)
const LL INF=0x7fffffff;
const LL LLF=0x7fffffffffffffff;
const LL MOD=998244353;
const LL MAX=10000+5;
LL tree[MAX<<2],pre[MAX],ans[MAX]; //线段树数组开四倍大小
void build(LL n,LL last);
LL query(LL pos,LL num,LL last);
int main(void){
	IOS;
	cin.tie(0);cout.tie(0);
    LL n;
    cin>>n;
    LL last=1<<((LL)(log(n)/log(2))+1);
    for(LL i=1;i<=n;++i){
        cin>>pre[i];
    }
    build(n,last);
    for(LL i=n;i;--i){
        ans[i]=query(1,pre[i]+1,last)-last+1;
    }
    for(LL i=1;i<=n;++i){
        cout<<ans[i]<<" ";
    }
    cout<<endl;
}
void build(LL n,LL last){
    for(LL i=last;i<last+n;++i){
        tree[i]=1;
    }
    while(last>>1){
        for(LL i=last>>1;i<last;++i){
            tree[i]=tree[i<<1]+tree[(i<<1)+1];
        }
        last>>=1;
    }
}
LL query(LL pos,LL num,LL last){
    --tree[pos];
    if(tree[pos]==0&&pos>=last){
        return pos;
    }
    if(tree[pos<<1]<num) return query((pos<<1)+1,num-tree[pos<<1],last);
    return query(pos<<1,num,last);
}
```

- 题目

​		给出N个数，进行Q个操作，1≤N，Q≤100000。有两种操作：
​		（1）“C a b c”，对区间[a，b]的每个数字加c。
​		（2）“Q a b”，查询区间[a，b]的数字和。

- 输入

​		N，Q，以及N个数字，Q个操作。

- 输出

​		对每个查询操作，输出结果。

- 样例输入

```
5 5
1 2 3 4 5
Q 2 3
C 2 4 1
Q 2 5
C 1 3 2
Q 1 5
```

- 样例输出

```
5
17
24
```

- 代码实现

```
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define LL long long
#define IOS ios::sync_with_stdio(0)
const LL INF=0x7fffffff;
const LL LLF=0x7fffffffffffffff;
const LL MOD=998244353;
const LL MAX=10000+5;
LL tree[MAX<<2],add[MAX<<2];
void push_up(LL root);
void push_down(LL root,LL len);
void build(LL l,LL r,LL root);
void update(LL a,LL b,LL c,LL l,LL r,LL root);
LL query(LL a,LL b,LL l,LL r,LL root);
int main(void){
	IOS;
	cin.tie(0);cout.tie(0);
    LL n,m;
    cin>>n>>m;
    build(1,n,1);
    while(m--){
        string str;
        cin>>str;
        if(str=="C"){
            LL a,b,c;
            cin>>a>>b>>c;
            update(a,b,c,1,n,1);
        }else{
            LL a,b;
            cin>>a>>b;
            cout<<query(a,b,1,n,1)<<endl;
        }
    }
}
void push_up(LL root){
    tree[root]=tree[root<<1]+tree[(root<<1)|1];
}
void push_down(LL root,LL len){
    if(add[root]){
        add[root<<1]+=add[root];
        add[root<<1|1]+=add[root];
        tree[root<<1]+=add[root]*((len>>1)+(len&1));
        tree[root<<1|1]+=add[root]*(len>>1);
        add[root]=0;
    }
}
void build(LL l,LL r,LL root){
    add[root]=0;
    if(l==r){
        cin>>tree[root];
        return;
    }
    LL mid=(l+r)>>1;
    build(l,mid,root<<1);
    build(mid+1,r,root<<1|1);
    push_up(root);
}
void update(LL a,LL b,LL c,LL l,LL r,LL root){
    if(a<=l&&b>=r){
        tree[root]+=(r-l+1)*c;
        add[root]+=c;
        return;
    }
    push_down(root,r-l+1);
    LL mid=(l+r)>>1;
    if(a<=mid) update(a,b,c,l,mid,root<<1);
    if(b>mid) update(a,b,c,mid+1,r,root<<1|1);
    push_up(root);
}
LL query(LL a,LL b,LL l,LL r,LL root){
    if(a<=l&&b>=r){
        return tree[root];
    }
    push_down(root,r-l+1);
    LL ans=0;
    LL mid=(l+r)>>1;
    if(a<=mid) ans+=query(a,b,l,mid,root<<1);
    if(b>mid) ans+=query(a,b,mid+1,r,root<<1|1);
    return ans;
}
```



#### 树状数组

- 题目

​		有编号是1~n的n个数字2≤n≤8000，乱序排列，顺序是未知的。对于每个位置的数字，知道排在它前面比它小的数字有多少个。求这个乱序数列的顺序。

- 输入

​		第一行输入数n。
​		第二行输入n个数。

- 输出

​		输出乱序数列的顺序。

- 样例输入

```
5
0 1 2 1 0
```

- 样例输出

```
2 4 5 3 1
```

- 代码实现：

```
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define LL long long
#define IOS ios::sync_with_stdio(0)
const LL INF=0x7fffffff;
const LL LLF=0x7fffffffffffffff;
const LL MOD=998244353;
const LL MAX=10000+5;
LL tree[MAX],pre[MAX],ans[MAX];
LL n;
LL lowbit(LL x);
void add(LL x, LL c);
LL sum(LL x);
LL findpos(LL data);
int main(void){
	IOS;
	cin.tie(0);cout.tie(0);
    cin>>n;
    for(LL i=1;i<=n;++i){
        cin>>pre[i];
    }
    for(LL i=1;i<=n;++i){
        tree[i]=lowbit(i);
    }
    for(LL i=n;i;--i){
        LL data=findpos(pre[i]+1);
        add(data,-1);
        ans[i]=data;
    }
    for(LL i=1;i<=n;++i){
        cout<<ans[i]<<" ";
    }
    cout<<endl;
}
LL lowbit(LL x){
    return x & -x;
}
void add(LL x, LL c){
    for (LL i = x; i <= n; i += lowbit(i)) tree[i] += c;
}
LL sum(LL x){
    LL ans = 0;
    for (LL i = x; i; i -= lowbit(i)) ans += tree[i];
    return ans;
}
LL findpos(LL data){
    LL l=1,r=n;
    while(l<r){
        LL mid=(l+r)>>1;
        if(sum(mid)<data){
            l=mid+1;
        }else{
            r=mid;
        }
    }
    return l;
}
```

- 题目

​		给定两个长度为N的排列A和B。若一对二元组下标(i，j)满足以下关系则被称之为压制二元组：
​		（1）1≤i<j≤N。
​		（2）P~Ai~<P~Bi~，其中P~x~表示值x在数组B中的下标。
​		一对压制二元组的价值被定义为j-i，请你计算出所有压制二元组的价值之和。
​		排列的定义：长度为N的排列表示一个长度为N的数组，其中[1,N]每个数都恰好出现一次。

- 输入

​		第一行输入一个整数N(1≤N≤2×10^5^）表示排列的长度。
​		第二行输入N个整数A~1~，A~2~，A~3~，...，A~N~表示排列A。
​		第三行输入N个整数B~1~，B~2~，B~3~，...，B~N~表示排列B。
​		保证A，B是一个排列。

- 输出

​		输出一个整数表示答案。

- 样例输入

```
4
2 4 1 3
4 1 2 3
```

- 样例输出

```
7
```

- 代码实现

```
#include <iostream>
using namespace std;
#define LL long long
LL n,a[200005],b[200005],shu[200005],zhi[200005];
LL lowbit(LL x);
LL sum(LL pos,LL p[]);
void update(LL pos,LL c,LL p[]);
int main(){
  cin>>n;
  for(int i=1;i<=n;++i){
    cin>>a[i];
  }
  for(LL i=1;i<=n;++i){
    LL x;
    cin>>x;
    b[x]=i;
  }
  LL ans=0;
  for(LL i=1;i<=n;++i){
    update(b[a[i]],1,shu);
    update(b[a[i]],i,zhi);
    ans+=i*sum(b[a[i]],shu)-sum(b[a[i]],zhi);
  }
  cout<<ans<<endl;
}
LL lowbit(LL x){
  return x&-x;
}
LL sum(LL pos,LL p[]){
  LL ans=0;
  for(LL i=pos;i;i-=lowbit(i)){
    ans+=p[i];
  }
  return ans;
}
void update(LL pos,LL c,LL p[]){
  for(LL i=pos;i<=n;i+=lowbit(i)){
    p[i]+=c;
  }
}
```

- 题目

​		小红拿到了一个数组，她想知道，有多少非空区间满足区间所有元素之和不小于k？

- 输入

​		第一行输入两个正整数n,k，用空格隔开。（1≤n≤10^5^，1≤k≤10^14^)
​		第二行输入n个整数a~i~，代表数组的元素。（−10^9^≤a~i~≤10^9^）

- 输出

​		输出一个整数表示满足条件区间的数量。

- 样例输入

```
4 5
2 -100 5 6
```

- 样例输出

```
3
```

- 代码实现

```
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define LL long long
#define DB double
#define IOS ios::sync_with_stdio(0)
const LL INF=0x7fffffff;
const LL LLF=0x7fffffffffffffff;
const LL MOD=998244353;
LL a[100005],b[100005],tree[100005];
LL n,k;
LL query(LL pos);
void update(LL pos);
LL lowbit(LL n);
void solve();
int main(void){
	IOS;
	cin.tie(0);cout.tie(0);
	LL t;
// 	cin>>t;
	t=1;
	while(t--){
		solve();
	}
}
void solve(){
    cin>>n>>k;
    for(LL i=1;i<=n;++i){
        cin>>a[i];
        a[i]+=a[i-1];
        b[i]=a[i];
    }
    sort(b+1,b+n+1);
    LL ans=0;
    for(LL i=1;i<=n;++i){
        LL p=upper_bound(b+1,b+n+1,a[i]-k)-b;
        ans+=query(p-1);
        if(a[i]>=k) ++ans;
        LL pp=lower_bound(b+1,b+n+1,a[i])-b;
        update(pp);
    }
    cout<<ans<<endl;
}
LL query(LL pos){
    LL ans=0;
    for(LL i=pos;i;i-=lowbit(i)){
        ans+=tree[i];
    }
    return ans;
}
void update(LL pos){
    for(LL i=pos;i<=n;i+=lowbit(i)){
        ++tree[i];
    }
}
LL lowbit(LL n){
    return n&-n;
}
```



### 3、动态规划

#### 基础DP

- 题目

​		给你一个数字三角形，第一行1个数字，第二行3个数字，第i行2∗i−1个数字，一共n行。如下图所示，为3行的数字三角形，一开始从顶点出发，当位于某一点时可以往这个点的正下方走，也可以往左下方和右下方走。 
​		例如在值为3的这一个点，可以往正下方走到7，也可以往左下方走到6，也可往右下方走到8（不能从3走到5或9）。 
​		每走到一个位置就会取出当前所在位置的值，问从顶点走到最后一层，最终的往左下方和往右下方的次数之差的绝对值不能超过k次，所取的数值总和的最大值为多少。 

- 输入

​		第一行输入n，k，1≤n≤300,0≤k≤300,k≤n。
​		接下来输入n行，第i行共2∗i−1个值，对于每个值x,−2∗10^9^≤x≤2∗10^9^。

- 输出

​		输出从顶点到底部的获取总和的最大值。

- 样例输入

```
3 1
1
2 3 4
5 6 7 8 9
```

- 样例输出

```
13
```

- 代码实现

```
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define IOS ios::sync_with_stdio(0)
#define LL long long
const LL INF=0x7fffffff;
const LL MOD=1e9+7;
const LL LLF=0x7fffffffffffffff;
LL jzt[305][605][5];
int main(void){
    LL n,k1;
    IOS;
    cin.tie(0);cout.tie(0);
    memset(jzt,-0x7f,sizeof jzt);
    cin>>n>>k1;
    for(LL i=1;i<=n;++i){
        for(LL j=1;j<(i<<1);++j){
            cin>>jzt[i][j][0];
        }
    }
    jzt[1][1][1]=jzt[1][1][0];
    jzt[1][1][2]=0;
    for(LL i=2;i<=n;++i){
        for(LL j=1;j<(i<<1);++j){
            for(LL k=j;k>j-3&&k>0;--k){
                LL data=jzt[i-1][k][1]+jzt[i][j][0];
                if(data>jzt[i][j][1]){
                    jzt[i][j][1]=data;
                    jzt[i][j][2]=jzt[i-1][k][2];
                    if(k==j){
                        ++jzt[i][j][2];
                    }else if(k==j-2){
                        --jzt[i][j][2];
                    }
                }
            }
        }
    }
    LL ans=-LLF;
    for(LL i=1;i<(n<<1);++i){
        if(abs(jzt[n][i][2])>k1) continue;
        if(jzt[n][i][1]>ans) ans=jzt[n][i][1];
    }
    cout<<ans<<endl;
}
```

- 题目

​		小金同学是一名正义感爆棚的预言师兼半吊子魔法师。这天他在路过一条河流时使用了预言术，并成功预言到了之后 n 天河流受自然因素影响（自然蒸发和降水）下的水位情况。具体来说，这 n 天河流的水位会依序构成一个长度为 n 的非负整数数列。
​		在小金看来，如果某一天河流的水位在 [l,r] 之间，这天就是无灾日；否则就认为这天极易出现洪涝或旱灾。身为一名富有正义感的预言师，他决定留在这条河边，控制河流的水位，保护周边村庄的安全。
​		但不幸的是，由于他只是一个半吊子魔法师，只会释放一种无咏唱水魔法：召唤一个龙卷风带走任意多的水。也就是说，他可以在任意一天使用魔法使河流的水位下降任意整数高度。当然，小金同学每天都能释放一次魔法，现在他想问问你，在最优情况下这 n 天中最多可能存在多少个无灾日？
​		请注意，如果在某时刻改变河流水位，那么所预言河流将来的水位也应随之变化。同时，河流的水位最低只可能为 0，不可能是负数。比如预言之后三天河流水位依次为：3,1,5，我们可以认为第二天由于干旱，水位下降 2 ，第三天由于降水，水位上升 4。如果小金在第一天让水位从 3 下降到 1 后，由于干旱，在第二天水位应下降到 0。又由于降水，第三天水位应上升到 4，所以河流水位应改变为1,0,4。

- 输入

​		第一行给出三个整数 n,l,r(1≤n≤5×10^3^,1≤l≤r≤10^9^)表示小金预言河流水位天数，以及安全河流水位的取值区间。
​		下一行给出 n 个整数，其中 a~i~(0≤a~i~≤5×10^3^) 表示预言第 i 天河流水位的值。

- 输出

​		输出一行共 1 个数，为这 n 天中最多可能有多少无灾日。

- 样例输入

```
3 2 5
8 1 3
```

- 样例输出

```
2
```

- 代码实现

```
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define LL long long
#define DB double
#define IOS ios::sync_with_stdio(0)
const LL INF=0x7fffffff;
const LL LLF=0x7fffffffffffffff;
const LL LLF_MID=0x7f7f7f7f7f7f7f7f;
const LL MOD=998244353;
LL h[5050];
LL dp[5050][5050];
void solve();
int main(void){
	IOS;
	cin.tie(0);cout.tie(0);
	LL t;
//	cin>>t;
	t=1;
	while(t--){
		solve();
	}
}
void solve(){
	LL n,l,r;
    cin>>n>>l>>r;
    for(LL i=1;i<=n;++i){
        cin>>h[i];
    }
    LL ans=0;
    for(LL i=1;i<=n;++i){
        for(LL j=h[i]-1;j>=0;--j){
            if(dp[i][j+1]>dp[i][j]) dp[i][j]=dp[i][j+1];
        }
        if(dp[i][0]>ans) ans=dp[i][0];
        for(LL j=r<h[i]?r:h[i];j>=l;--j){
            ++dp[i][j];
            if(ans<dp[i][j]) ++ans;
        }
        for(LL j=h[i+1],k=h[i];k>=0;--j,--k){
            if(j<0) j=0; 
            dp[i+1][j]=dp[i][k]>dp[i+1][j]?dp[i][k]:dp[i+1][j];
        }
    }
    cout<<ans<<endl;
}
```

- 最长公共子序列
- 代码实现

```
#include<bits/stdc++.h>
using namespace std;
int dp[1005][1005];
string str1,str2;
int LCS();
int main(void){
    while(cin>>str1>>str2){
        cout<<LCS()<<endl;
    }
}
int LCS(){
    memset(dp,0,sizeof dp);
    for(int i=1;i<=str1.size();++i){
        for(int j=1;j<=str2.size();++j){
            if(str1[i-1]==str2[j-1]){
                dp[i][j]=dp[i-1][j-1]+1;
            }else{
                dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
            }
        }
    }
    return dp[str1.size()][str2.size()];
}
```

- 最长递增子序列
- 代码实现（DP）

```
#include<bits/stdc++.h>
using namespace std;
int dp[10005],high[100005],n;
int LIS();
int main(void){
    while(cin>>n){
        for(int i=1;i<=n;++i){
            cin>>high[i];
        }
        cout<<LIS()<<endl;
    }
}
int LIS(){
    memset(dp,0,sizeof dp);
    int ans=1;
    dp[1]=1;
    for(int i=2;i<=n;++i){
        int max=0;
        for(int j=1;j<i;++j){
            if(dp[j]>max&&high[j]<high[i]){
                max=dp[j];
            }
        }
        dp[i]=max+1;
        if(dp[i]>ans) ans=dp[i];
    }
    return ans;
}
```

- 代码实现（非DP）

```
#include<bits/stdc++.h>
using namespace std;
int d[10005],high[100005],n;
int LIS();
int main(void){
    while(cin>>n){
        for(int i=1;i<=n;++i){
            cin>>high[i];
        }
        cout<<LIS()<<endl;
    }
}
int LIS(){
    memset(d,0,sizeof d);
    int ans=1;
    d[1]=high[1];
    for(int i=2;i<=n;++i){
        if(high[i]>d[ans]){
            d[++ans]=high[i];
        }else{
            int j=lower_bound(d+1,d+ans+1,high[i])-d;
            d[j]=high[i];
        }
    }
    return ans;
}
```



#### 区间DP

- 题目

​		有n堆石子排成一排，每堆石子有一定的数量，将n堆石子合并成一堆。合并的规则是每次只能合并相邻的两堆石子，合并的花费为这两堆石子的总数。石子经过n-1次合并后成为一堆，求总的最小花费。

- 输入

​		有多组测试数据，输入到文件结束。每组测试数据的第1行有一个整数n，表示有n堆石子，n<250。接下来的一行有n个数，分别表示这n堆石子的数目。每堆石子至少1颗，最多10000颗。

- 输出

​		总的最小花费。

- 样例输入

```
3
2 4 5
```

- 样例输出

```
17
```

- 代码实现

```
#include<bits/stdc++.h>
using namespace std;
const int INF = 1<<30;
const int N = 300;
int sum[N],n;
int Minval();
int main(void){
    while(cin>>n){
        sum[0]=0;
        for(int i=1;i<=n;++i){
            int x;
            cin>>x;
            sum[i]=sum[i-1]+x;
        }
        cout<<Minval()<<endl;
    }
}
int Minval(){
    int dp[N][N],s[N][N];
    for(int i=1;i<=n;++i){
        dp[i][i]=0;
        s[i][i]=i;
    }
    for(int len=1;len<n;++len){
        for(int i=1;i<=n-len;++i){
            int j=i+len;
            dp[i][j]=INF;
            for(int k=s[i][j-1];k<=s[i+1][j];++k){
                int data=dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1];
                if(data<dp[i][j]){
                    dp[i][j]=data;
                    s[i][j]=k;
                }
            }
        }
    }
    return dp[1][n];
}
```



#### 数位DP

- 题目

​		给定一个正整数 n，你可以对 n 进行任意次（包括零次如下操作：选择 n 上的某一数位，将其删去，剩下的左右部分合并。例如 123 ，你可以选择删去第二位 2，得到新数 13。 
​		在对 n 进行操作后，请问有多少种不同的 n，使得 n 不是 3 的倍数？
​		由于结果可能非常大，请输出对 1000000007 取模的结果。

- 输入

​		第一行包含一个正整数 n。（1≤n≤10^200000^）
​		数据保证最初生成的 n 不含前导 0。

- 输出

​		输出一行，代表对 1000000007 取模后的结果。

- 样例输入

```
1234
```

- 样例输出

```
10
```

- 代码实现

```
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define LL long long
#define IOS ios::sync_with_stdio(0)
const int INF=0x7fffffff;
const LL LLF=0x7fffffffffffffff;
const LL MOD=1000000007;
LL dp[200005][3];
LL pre[10]={1};
int main(void){
	IOS;
	cin.tie(0);cout.tie(0);
    string str;
    cin>>str;
    str=" "+str;
    dp[0][0]=1;
    for(LL i=1;i<str.size();++i){
        LL data=str[i]^48;
        for(LL j=0;j<3;++j){
            dp[i][(j+data)%3]=(dp[i-1][(j+data)%3]+dp[i-1][j])%MOD;
        }
        if(pre[data]){
            for(LL j=0;j<3;++j){
                dp[i][(j+data)%3]=(dp[i][(j+data)%3]+MOD-dp[pre[data]-1][j])%MOD;
            }
        }
        pre[data]=i;
    }
    cout<<(dp[str.size()-1][1]+dp[str.size()-1][2])%MOD<<endl;
}
```

- 题目

​		定义一种函数 f(x) ，f(x) 的值与 x 的数位有关，f(x) 开始值为 0。
​		（1）x 的数位中每存在一个 7 ， f(x) 结果增加 3 。
​		（2）x 的数位中每存在一个  5 ， f(x) 结果增加 1。
​		（3）x 的数位中存在连续  7 个 7 ， f(x) 结果增加 300。
​		例如：f(1234)=0,f(55)=2,f(757)=7,f(7777777)=321,f(77777777777777)=342。
​		多组询问，对于每组询问存在一对 l,r, 你需要输出 ∑^r^~i=l~f(i) 的值。

- 输入

​		第一行一个正整数 T 代表询问次数。（T≤10^5^）
​		接下来 T 行，每行两个正整数 l,r。(1≤l≤r≤10^18^)

- 输出

​		T 行，每行一个正整数表示结果。

- 样例输入

```
2
1 10
10 100
```

- 样例输出

```
4
76
```

- 代码实现

```
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define LL long long
#define IOS ios::sync_with_stdio(0)
const LL INF = 0x7fffffffffffffff;
LL dp[20][20][10],dp7[20][1<<7][2],shu[20],shu_dex;
LL solve(LL n);
void get(LL n);
LL dfs(LL pos,LL num,bool limit,LL cnt);
LL dfs2(LL pos,LL st,bool limit,bool have);
int main(void){
	IOS;
	cin.tie(0);cout.tie(0);
    memset(dp,-1,sizeof dp);
    memset(dp7,-1,sizeof dp7);
	LL t;
    cin>>t;
    while(t--){
        LL l,r;
        cin>>l>>r;
        cout<<solve(r)-solve(l-1)<<endl;
    }
}
LL solve(LL n){
    get(n);
    return dfs(shu_dex,7,1,0)*3+dfs(shu_dex,5,1,0)+dfs2(shu_dex,0,1,0)*300;
}
void get(LL n){
    shu_dex=0;
    
    while(n){
        shu[++shu_dex]=n%10;
        n/=10;
    }
}
LL dfs(LL pos,LL num,bool limit,LL cnt){
    if(!pos) return cnt;
    if(~dp[pos][cnt][num]&&!limit) return dp[pos][cnt][num];
    LL mmax=limit?shu[pos]:9;
    LL ans=0;
    for(LL i=0;i<=mmax;++i){
        ans+=dfs(pos-1,num,limit&&i==mmax,cnt+(i==num));
    }
    if(!limit) dp[pos][cnt][num]=ans;
    return ans;
}
LL dfs2(LL pos,LL st,bool limit,bool have){
    if(!pos) return have;
    if(~dp7[pos][st][have]&&!limit) return dp7[pos][st][have];
    LL mmax=limit?shu[pos]:9;
    LL ans=0;
    for(LL i=0;i<=mmax;++i){
        LL rst=((st&((1<<6)-1))<<1)|i==7;
        ans+=dfs2(pos-1,rst,limit&&i==mmax,have||rst==(1<<7)-1);
    }
    if(!limit) dp7[pos][st][have]=ans;
    return ans;
}
```



### 4、数学

#### 概率与数学期望

- 题目

​		一个软件有s个子系统，会产生n中bug。现在要找出所有种类的bug。假设某人一天发现一个bug。一个bug属于某个子系统的概率是1/s，属于某种分类的概率是1/n。问发现n种bug，且每个子系统都发现bug的天数的期望。

- 输入

​		n和s，n和s均大于0且小于1000。

- 输出

​		数学期望。

- 样例输入

```
1 2
```

- 样例输出

```
3
```

- 答案解析

```
	定义状态dp[i][j]，它表示已经找到i种bug，并存在于j个子系统中，要达到目标状态还需要的期望天数。其中dp[n][s]表示已经找到n种bug，且存在于s个子系统，说明已经达到了目标，还需要0天，所以dp[n][s]=0。从dp[n][s]倒推回dp[0][0]，就是本题的答案，即还没有找到任何bug的情况下到达dp[n][s]时需要的期望天数。
	从dp[i][j]开始：后面1天找到1个bug，可能有以下4种情况:
	(1)dp[i][j]：发现一个bug，属于已经有的i个分类和j个系统，概率为p1=(i/n)	*(j/s)。这一天相当于浪费了。
	(2)dp[i+1][j]：发现一个bug，不属于已有分类、属于已有系统，概率为p2=(1-i/n)*(j/s)。
	(3)dp[i][j+1]：发现一个 bug，属于已有分类、不属于已有系统,概率为p3=(i/n)+(1-j/s)。
	(4)dp[i+1][j+1]：发现一个bug，不属于已有系统、不属于已有分类，概率p4=(1-i/n)*(1—j/s)。
	可以验证：p1+p2+p3+p4=1。
	状态转移方程如下：dp[i][j]=p1*dp[i][j]+p2*dp[i+1][j]+p3*dp[i][j+1]+p4*dp[i+1][j+1]+1 //末尾加上1天
```

- 代码描述

```
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define IOS ios::sync_with_stdio(0)
#define LL long long
double dp[1005][1005];
int main(void){
    IOS;
    cin.tie(0);cout.tie(0);
    LL n,s;
    cin>>n>>s;
    for(LL i=n;i>=0;--i){
        for(LL j=s;j>=0;--j){
            if(i==n&&j==s){
                dp[n][s]=0;
            }else{
                dp[i][j]=(n*s+(n-i)*j*dp[i+1][j]+i*(s-j)*dp[i][j+1]+(n-i)*(s-j)*dp[i+1][j+1])/(n*s-i*j);
            }
        }
    }
    cout<<dp[0][0]<<endl;
}
```



#### 公平组合游戏

- 巴什游戏
- 题目

​		有n颗石子，甲先取，乙后取，每次可以拿1~m颗石子，轮流拿下去，拿到最后一颗的人获胜。

- 输入

​		n和m，1≤n，m≤1000。

- 输出

​		如果先拿的甲赢了，输出"first"，否则输出"second"。

- 样例输入

```
5 4
```

```
6 4
```

- 样例输出

```
second
```

```
first
```

- 代码实现

```
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define IOS ios::sync_with_stdio(0)
#define LL long long
int main(void){
    IOS;
    cin.tie(0);cout.tie(0);
    LL n,m;
    cin>>n>>m;
    if(n%(m+1)) cout<<"first"<<endl;
    else cout<<"second"<<endl;
}
```

- 尼姆游戏
- 题目

​		有n堆石子，数量分别是(a~1~，a~2~，a~3~，…，a~n~)，两个玩家轮流拿石子，每次从任意一堆中拿走任意数量的石子，拿到最后一个石子的玩家获胜。

- 输入

​		第一行输入n，代表有n堆石子，n大于0且小于100。
​		第二行输入n个数(a~1~，a~2~，a~3~，…，a~n~)，a~i~代表第 i 堆石子的个数。

- 输出

​		若先手能赢则输出“first”，否则输出“second”。

- 样例输入

```
3
1 1 3
```

```
3
1 1 0
```

- 样例输出

```
first
```

```
second
```

- 代码实现

```
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define IOS ios::sync_with_stdio(0)
#define LL long long
int main(void){
    IOS;
    cin.tie(0);cout.tie(0);
    LL n;
    cin>>n;
    LL m=0;
    for(LL i=1;i<=n;++i){
        LL data;
        cin>>data;
        m^=data;
    }
    if(m) cout<<"first"<<endl;
    else cout<<"second"<<endl;
}
```

- 图游戏与SG函数
- 题目

​		小Y天天不吃早饭，于是他买了n堆饼干准备当早饭吃，每堆饼干有s~i~块。小C也不吃早饭，于是小Y”好心“的将饼干分给小C吃，并要求玩个游戏，谁输了，就要受到严酷的惩罚。
​		游戏规则如下：每个人轮流吃饼干，每次只能选择一堆吃，小Y先吃。每个人每次吃饼干的数量是有限的正整数区间[a,b]，每次至少吃a块饼干才不会挨饿。如果有一堆饼干的数量大于b块，那么他们最多也只能吃b块，如果有一堆的饼干数量小于a块，那么他们为了不挨饿，就不会吃这一堆饼干。如果在一次操作中，有人无论如何都要挨饿，那么他就输了。
​		小Y和小C都非常聪明，都不想受到严酷的惩罚，于是他们问向更聪明的你，谁最后会受到严酷的惩罚。

- 输入

​		第一行输入n,a,b分别表示饼干的堆数，不挨饿所需的最少饼干数和不挨饿所需的最多饼干数。(1≤n≤10^6^,1≤a≤b≤10^4^)
​		第二行 输入n个数 s~1~,s~2~,...,s~n~，s~i~表示第 i 堆饼干有s<sub>i</sub>块。(0≤s~i~≤10^4^)

- 输出

​		输出一个字母，如果小Y受到严酷的惩罚就输出”Y“，否则输出”C"

- 样例输入

```
5 2 3
1 4 1 1 5
```

```
5 2 4
1 4 1 1 5
```

- 样例输出

```
C
```

```
Y
```

- 代码实现

```
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define IOS ios::sync_with_stdio(0)
#define LL long long
const LL INF=0x7fffffff;
const LL MOD=1e9+7;
const LL LLF=0x7fffffffffffffff;
LL sg[1000005];
bool flag[1000005];
void init(LL a,LL b);
int main(void){
    IOS;
    cin.tie(0);cout.tie(0);
    LL n,a,b;
    cin>>n>>a>>b;
    init(a,b);
    b+=a;
    LL ans=0;
    for(LL i=1;i<=n;++i){
        LL data;
        cin>>data;
        data%=b;
        ans^=sg[data];
    }
    if(ans) cout<<"C";
    else cout<<"Y";
}
void init(LL a,LL b){
    for(LL i=a;i<=a+b-1;++i){
        memset(flag,0,sizeof flag);
        for(LL j=i-a;j>=0&&j>=i-b;--j){
            flag[sg[j]]=1;
        }
        LL j=0;
        while(flag[j]){
            ++j;
        }
        sg[i]=j;
    }
}
```

- 威佐夫游戏
- 题目

​		有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定每次有两种不同的取法，一是可以从任意的一堆中取走任意多的石子；二是可以从两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。
​		现在给出初始的两堆石子的数目a和b，问先手玩家是不是最后的胜者？

- 输入

​		两个数a和b，a和b均大于0且小于100。

- 输出

​		若先手能赢则输出“first”，否则输出“second”。

- 样例输入

```
4 7
```

- 样例输出

```
second
```

- 代码实现

```
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define IOS ios::sync_with_stdio(0)
#define LL long long
int main(void){
    IOS;
    cin.tie(0);cout.tie(0);
    LL a,b;
    cin>>a>>b;
    if(a>b) a^=b^=a^=b;
    double gold=(1+sqrt(5))/2;
    LL test=gold*(b-a);
    if(a!=test) cout<<"first"<<endl;
    else cout<<"second"<<endl;
}
```



### 5、字符串

#### 字符串哈希

- 题目

​		许多应用程序，如字处理软件，邮件客户端等，都包含了单词检查特性。单词检查是根据字典，找出输入文本中拼错的单词，我们认为凡是不出现在字典中的单词都是错误单词。不仅如此，一些检查程序还能给出类似拼错单词的修改建议单词。 例如字典由下面几个单词组成：bake cake main rain vase。
​		如果输入文件中有词vake ，检查程序就能发现其是一个错误的单词，并且给出 bake, cake或vase做为修改建议单词。
​		修改建议单词可以采用如下生成技术：
​				(1)在每一个可能位置插入‘a-'z'中的一者。
​				(2)删除单词中的一个字符。
​				(3)用‘a'-'z'中的一者取代单词中的任一字符。
​		很明显拼写检查程序的核心操作是在字典中查找某个单词，如果字典很大，性能无疑是非常关键的。你写的程序要求读入字典文件，然后对一个输入文件的单词进行检查，列出其中的错误单词并给出修改建议。

- 输入

​		输入分为两部分。
​		第一部分是字典，每个单词占据一行，最后以仅包含'#'的一行表示结束。所有的单词都是不同的，字典中最多500000个单词。
​		输入的第二部分包含了所有待检测的单词，单词数目不超过200。每个单词占据一行，最后以仅包含'#'的一行表示结束。
​		字典中的单词和待检测的单词均由小写字母组成，并且单词最大长度为15。

- 输出

​		按照检查次序每个单词输出一行，该行首先输出单词自身。如果单词在字典中出现，接着输出" is correct"。如果单词是错误的，那么接着输出':'，如果字典中有建议修改单词，则按照字典中出现的先后次序输出所有的建议修改单词（每个前面都添加一个空格），如果无建议修改单词，在':'后直接换行。

- 样例输入

```
i
is
has
have
be
my
more
contest
me
too
if
award
#
me
aware
m
contest
hav
oo
or
i
fi
mre
#
```

- 样例输出

```
me is correct
aware: award
m: i my me
contest is correct
hav: has have
oo: too
or:
i is correct
fi: i
mre: more me
```

- 代码实现

```
#include<bits/stdc++.h>
using namespace std;
#define IOS ios::sync_with_stdio(false)
#define endl '\n'
#define LL long long 
const LL MOD=0233333;
struct haxi{
    string data;
    int dex;
};
int dex_zifu=0;
vector<vector<haxi> > vec(233333);
string zifu[500005];
bool cun[500005];
void build(string data);
void solve(string data);
void charu(string data);
void shanchu(string data);
void tidai(string data);
int find(string data);
int main(void){
    IOS;
    cin.tie(0);cout.tie(0);
    while(cin>>zifu[dex_zifu]){
        if(zifu[dex_zifu]=="#") break;
        build(zifu[dex_zifu]);
        ++dex_zifu;
    }
    string data;
    while(cin>>data){
        if(data=="#"){
            return 0;
        }
        solve(data);
        cout.flush();
    }
}
void solve(string data){
    if(find(data)!=-1){
        cout<<data<<" is correct"<<endl;
        return;
    }
    charu(data);
    shanchu(data);
    tidai(data);
    cout<<data<<':';
    for(int i=0;i<dex_zifu;++i){
        if(cun[i]){
            cout<<' '<<zifu[i];
            cun[i]=0;
        }
    }
    cout<<endl;
}
int find(string data){
    int count=1;
    for(int i=0;i<data.size();++i){
        count=count*(data[i]-96)*26%MOD;
    }
    for(int i=0;i<vec[count].size();++i){
        if(vec[count][i].data==data) return vec[count][i].dex;
    }
    return -1;
}
void charu(string data){
    for(int i=0;i<=data.size();++i){
        for(int j=97;j<123;++j){
            string data2=data,zi="";
            zi+=char(j);
            data2.insert(i,zi);
            int count=find(data2);
            if(count!=-1){
                cun[count]=1;
            }
        }
    }
}
void shanchu(string data){
    for(int i=0;i<data.size();++i){
        string data2=data;
        data2.erase(i,1);
        int count=find(data2);
        if(count!=-1){
            cun[count]=1;
        }
    }
}
void tidai(string data){
    for(int i=0;i<data.size();++i){
        string data2=data;
        for(int j=97;j<123;++j){
            if(data[i]!=j){
                data2[i]=j;
                int count=find(data2);
                if(count!=-1){
                    cun[count]=1;
                }
            }
        }
    }
}
void build(string data){
    int count=1;
    for(int i=0;i<data.size();++i){
        count=count*(data[i]-96)*26%MOD;
    }
    haxi p{data,dex_zifu};
    vec[count].push_back(p);
}
```



#### KMP

- 代码实现

```
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define IOS ios::sync_with_stdio(0)
#define LL long long
LL next1[200005];
void next_(string str);
LL find_(string str1,string str2,LL l);
int main(void){
    IOS;
    cin.tie(0);cout.tie(0);
    string str1,str2;
    cin>>str1>>str2;
    next_(str2);
    LL l=0,ans=0;
    while(l<str1.size()){
        l=find_(str1,str2,l)+1;
        if(!l){
            break;
        }
        ++ans;
    }
    cout<<ans<<endl;
}
LL find_(string str1,string str2,LL l){
    LL r=0;
    while(l<(LL)str1.size()&&r<(LL)str2.size()){
        if(r==-1||str1[l]==str2[r]){
            ++l;
            ++r;
        }else{
            r=next1[r];
        }
    }
    if(r==str2.size()) return l-str2.size();
    return -1;
}
void next_(string str){
    LL l=-1,r=0;
    next1[r]=l;
    while(r<(LL)str.size()-1){
        if(l==-1||str[r]==str[l]){
            ++r;
            ++l;
            if(str[l]==str[r]){
                next1[r]=next1[l];
            }else{
                next1[r]=l;
            }
        }else{
            l=next1[l];
        }
    }
}
```



#### AC自动机

- 题目

​		有多个关键词，在一个文本中找到它们。

- 输入

​		第1行是测试用例个数。每个用例包括一个整数N，表示关键词个数，下面有N个关键词，N≤10000。每个关键词只包括小写字母，长度不超过50。最后一行是文本，长度不大于1000000。

- 输出

​		在输出文本中能找到多少关键词。重复的关键词只需要统计一次。

- 样例输入

```
1
3
you
are
cool
hahahahayouaresocool
```

- 样例输出

```
3
```

- 代码实现

```
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define LL long long
#define IOS ios::sync_with_stdio(0)
bool val[10005]={0},flag[10005]={0};
int fail[10005]={0},next1[10005]={0},node[10005][28]={0};
int node_dex,ans;
void insert_(string data);
void find_(string data);
void ans_(int p);
void fail_next1();
int main(void){
    IOS;
    cin.tie(0);cout.tie(0);
    int t;
    cin>>t;
    while(t--){
        int n;
        cin>>n;
        memset(node[0],0,sizeof node[0]);
        node_dex=0;
        ans=0;
        for(int i=1;i<=n;++i){
            string data;
            cin>>data;
            insert_(data);
        }
        fail_next1();
        string data;
        cin>>data;
        find_(data);
        cout<<ans<<endl;
    }
    cout.flush();
}
void insert_(string data){
    int p=0;
    for(int i=0;i<data.size();++i){
        int c=data[i]-'a';
        if(!node[p][c]){
            node[p][c]=++node_dex;
            memset(node[node_dex],0,sizeof node[node_dex]);
            val[node_dex]=0;
            flag[node_dex]=0;
        }
        p=node[p][c];
    }
    val[p]=1;
}
void find_(string data){
    int p=0;
    for(int i=0;i<data.size();++i){
        p=node[p][data[i]-'a'];
        if(val[p]) ans_(p);
        else if(next1[p]) ans_(next1[p]);
    }
}
void ans_(int p){
    if(p&&!flag[p]){
        ++ans;
        flag[p]=1;
        ans_(next1[p]);
    }
}
void fail_next1(){
    queue<int> que;
    for(int i=0;i<26;++i){
        if(node[0][i]){
            que.push(node[0][i]);
        }
    }
    while(que.size()){
        int r=que.front();
        que.pop();
        for(int i=0;i<26;++i){
            int u=node[r][i];
            if(!u){
                node[r][i]=node[fail[r]][i];
                continue;
            }
            que.push(u);
            int v=fail[r];
            while(v&&!node[v][i]) v=fail[v];
            fail[u]=node[v][i];
            next1[u]=val[fail[u]]?fail[u]:next1[fail[u]];
        }
    }
}
```



### 6、图论

#### 最短路

- 题目

​		有多个城市组成一个铁路交通网络。任意两个城市之间有直连铁路，或者通过其他城市间接到达。给定某个城市，要求在M时间内能从该城市到达任意指定的另一城市，求最小的M。

- 输入

​		输入由多组测试用例组成。
​		每个测试用例由多行组成，第一行是整数n（1 <= n <= 100），表示城市的数目。
​		其余行表示邻接矩阵A。A(i,j)的值如果是一个整数t，表示城市i与城市j有铁路直连，需要t时间到达另一方。如果A(i,j)的值为x，表明城市i与城市j之间没有直连铁路。很明显有A(i,i) = 0。
​		由于对称关系和A(i,i) 为 0，输入只给出矩阵的下三角。第一行A(1,1)在输入中省略，第二行只有A(2,1)，下一行则是A(3,1) 和A(3,2)，依此类推。

- 输出

​		输出城市1所对应的最小M。

- 样例输入

```
5
50
30 5
100 20 50
10 x x 10
```

- 样例输出

```
35
```

- 弗洛伊德算法实现

```
#include<bits/stdc++.h>
using namespace std;
const int INF = 1e6;
const int NUM = 105;
int graph[NUM][NUM];
int n;
string lujin;
void floyd();
int main(void){
    while(cin>>n){
        for(int i=2;i<=n;++i){
            for(int j=1;j<i;++j){
                cin>>lujin;
                if(lujin=="x") graph[j][i]=graph[i][j]=INF;
                else{
                    int ans=0;
                    for(int i=0;i<lujin.size();++i){
                        ans=ans*10+lujin[i]-48;
                    }
                    graph[j][i]=graph[i][j]=ans;
                }
            }
        }
        floyd();
    }
}
void floyd(){
    for(int k=1;k<=n;++k){
        for(int i=1;i<=n;++i){
            if(graph[i][k]!=INF){
                for(int j=1;j<=n;++j){
                    int data=graph[i][k]+graph[k][j];
                    if(data<graph[i][j]){
                        graph[i][j]=data;
                    }
                }
            }
        }
    }
    int ans=0;
    for(int i=1;i<=n;++i){
        if(graph[1][i]>ans) ans=graph[1][i];
    }
    cout<<ans<<endl;
}
```

- 贝尔曼算法实现

```
#include<bits/stdc++.h>
using namespace std;
const int INF = 1e6;
const int NUM = 105;
struct edge{
    int u,v,w;
}e[100005];
int n,cnt,pre[NUM];
string lujin;
void print_path(int s,int t);
void bellman();
int main(void){
    while(cin>>n){
        for(int i=2;i<=n;++i){
            for(int j=1;j<i;++j){
                cin>>lujin;
                int ans=0;
                if(lujin=="x"){
                    ans=INF;
                }else{
                    for(int i=0;i<lujin.size();++i){
                        ans=ans*10+lujin[i]-48;
                    }
                }
                e[cnt].u=i;
                e[cnt].v=j;
                e[cnt].w=ans;
                ++cnt;
                e[cnt].u=j;
                e[cnt].v=i;
                e[cnt].w=ans;
                ++cnt;
            }
        }
        bellman();
    }
}
void bellman(){
    int d[NUM];
    for(int i=1;i<=n;++i){
        d[i]=INF;
    }
    d[1]=0;
    for(int k=1;k<=n;++k){
        for(int i=0;i<cnt;++i){
            int x=e[i].u,y=e[i].v;
            int data=d[y]+e[i].w;
            if(d[x]>data){
                d[x]=data;
                pre[x]=y;
            }
        }
    }
    int ans=0;
    for(int i=1;i<=n;++i){
        if(ans<d[i]) ans=d[i];
    }
    cout<<ans<<endl;
}
void print_path(int st,int ed){ //可打印从st到ed的最短路径
    if(st==ed){
        cout<<st;
        return;
    }
    print_path(st,pre[ed]);
    cout<<" "<<ed;
}
```

- 迪杰斯特拉算法实现

```
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define LL long long 
#define DB double 
#define IOS ios::sync_with_stdio(0)
const LL MOD=1e9+7;
LL n,juzhen[105][105],changdu[105];
bool sure[105];
void solve();
int main(void){
    IOS;
    cin.tie(0);cout.tie(0);
    while(cin>>n){
        string lujin;
        for(LL i=2;i<=n;++i){
            for(LL j=1;j<i;++j){
                cin>>lujin;
                if(lujin=="x") juzhen[j][i]=juzhen[i][j]=MOD;
                else{
                    LL ans=0;
                    for(LL i=0;i<lujin.size();++i){
                        ans=ans*10+lujin[i]-48;
                    }
                    juzhen[j][i]=juzhen[i][j]=ans;
                }
            }
        }
        solve();
        cout.flush();
    }
    cout.flush();
}
void solve(){
    for(LL i=2;i<=n;++i){
        sure[i]=0;
        changdu[i]=juzhen[1][i];
    }
    sure[1]=1;
    for(LL i=1;i<n;++i){
        LL ans=MOD,dex=0;
        for(LL j=2;j<=n;++j){
            if(!sure[j]&&ans>changdu[j]){
                ans=changdu[j];
                dex=j;
            }
        }
        if(!dex) break;
        sure[dex]=1;
        for(LL j=2;j<=n;++j){
        LL data=juzhen[dex][j]+changdu[dex]；
            if(data<changdu[j]){
                changdu[j]=data;
            }
        }
    }
    LL ans=0;
    for(LL i=2;i<=n;++i){
        if(changdu[i]>ans) ans=changdu[i];
    }
    cout<<ans<<endl;
}
```



#### 最小生成树

- 题目

​		你领到了一个铺设校园内自来水管道的任务。校园内有若干需要供水的点，每两个供水点可能存在多种铺设路径。对于每一种铺设路径，其成本是预知的。任务要求最终铺设的管道保证任意两点可以直接或间接的联通，同时总成本最低。

- 输入

​		每个测试用例由多行组成，第一行是两个整数P和R，P代表供水点数（1<=P<=50），每个点都对应1到P中的一个唯一编号。R代表可能的铺设路径数，路径数可能有非常多。接下有R行，每行格式如下：
​		节点A编号 节点B编号 路径成本。
​		路径成本不超过100。
​		测试用例之间有一空行分开。输入结束用P=0表示，注意没有R值。

- 输出

​		每个测试用例占用一行输出最低总成本。

- 样例输入

```
1 0

2 3
1 2 37
2 1 17
1 2 68

3 7
1 2 19
2 3 11
3 1 7
1 3 5
2 3 89
3 1 91
1 2 32

5 7
1 2 5
2 3 7
2 4 8
4 5 11
3 5 10
1 5 6
4 2 12

0
```

- 样例输出

```
0
17
16
26
```

- 克鲁斯卡尔算法实现

```
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define LL long long 
#define DB double 
#define IOS ios::sync_with_stdio(0)
const LL MOD=1e9+7;
struct node{
    LL qian,hou,data;
}shuiguan[1000005];
LL m,n,point[105];
bool cmp(node a,node b);
void solve();
int main(void){
    IOS;
    cin.tie(0);cout.tie(0);
    while(cin>>n){
        if(!n) return 0;
        cin>>m;
        for(LL i=1;i<=m;++i){
            cin>>shuiguan[i].qian>>shuiguan[i].hou>>shuiguan[i].data;
        }
        sort(shuiguan+1,shuiguan+1+m,cmp);
        solve();
        cout.flush();
    }
    cout.flush();
}
void solve(){
    for(LL i=1;i<=n;++i){
        point[i]=i;
    }
    LL ans=0;
    for(LL i=1;i<=m;++i){
        if(point[shuiguan[i].qian]!=point[shuiguan[i].hou]){
            ans+=shuiguan[i].data;
            LL qian=point[shuiguan[i].qian];
            for(LL j=1;j<=n;++j){
                if(point[j]==qian){
                    point[j]=point[shuiguan[i].hou];
                }
            }
        }
    }
    cout<<ans<<endl;
}
bool cmp(node a,node b){
    return a.data<b.data;
}
```

