# 基础题录

## 动态规划

- 题目：[Problem - C - Codeforces](https://codeforces.com/contest/1935/problem/C)
- 代码实现：

```
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define endl '\n'
#define DB double
const LL LLF=1e9+7;
void solve();
int main(void){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	LL t;
	cin>>t;
//	t=1;
	while(t--){
		solve();
	}
}
void solve(){
	LL n,l;
	cin>>n>>l;
	vector<LL> a(n),b(n);
	for(LL i=0;i<n;++i){
		cin>>a[i]>>b[i];
	}
	vector<LL> p(n);
	iota(p.begin(),p.end(),0);
	sort(p.begin(),p.end(),
		[&](LL i,LL j){
			return b[i]<b[j];
		}
	);
	vector<LL> dp(n+1,LLF);
	LL ans=0;
	for(auto i:p){
		for(LL j=n-1;j;--j){
			dp[j+1]=min(dp[j+1],dp[j]+a[i]);
			if(dp[j]+a[i]+b[i]<=l){
				ans=max(ans,j+1);
			}
		}
		dp[1]=min(dp[1],a[i]-b[i]);
		if(a[i]<=l){
			ans=max(ans,1LL);
		}
	}
	cout<<ans<<endl;
}
```

- 题目：[D-我不是大富翁_牛客小白月赛88 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/75771/D)
- 代码实现：

```
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define endl '\n'
#define DB double
LL d[10005];
LL read(){
    LL ans=0;
    char ch;
    ch=getchar();
    while(ch>='0'&&ch<='9'){
        ans=(ans<<3)+(ans<<1)+(ch^'0');
        ch=getchar();
    }
    return ans;
}
void solve();
int main(void){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	LL t;
// 	cin>>t;
	t=1;
	while(t--){
		solve();
	}
}
void solve(){
    LL n,k;
    n=read();
    k=read();
    vector<LL> vec(k+1);
    vector<vector<bool>> dp(k+1,vector<bool>(n+1,0));
    for(LL i=1;i<=k;++i){
        vec[i]=read();
        vec[i]%=n;
    }
    dp[0][0]=true;
    for(LL i=1;i<=k;++i){
        for(LL j=0;j<n;++j){
            if(dp[i-1][j]){
                dp[i][(j+vec[i])%n]=true;
                dp[i][(j-vec[i]+n)%n]=true;
            }
        }
    }
    cout<<(dp[k][0]?"YES":"NO")<<endl;
}
```

- 题目：[G-旗鼓相当的对手_第十一届"图灵杯"NEUQ-ACM程序设计竞赛 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/76681/G)
- 代码实现：

```
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define LL long long
#define DB double
#define IOS ios::sync_with_stdio(0)
const LL INF=0x7fffffff;
const LL LLF=0x7fffffffffffffff;
const LL LLF_MID=0x7f7f7f7f7f7f7f7f;
const LL MOD=998244353;
const LL N=400005;
bool dp[N],dp2[N];
void solve();
int main(void){
	IOS;
	cin.tie(0);cout.tie(0);
	LL t;
// 	cin>>t;
	t=1;
	while(t--){
		solve();
	}
}
void solve(){
    LL n;
    cin>>n;
    dp[200000]=true;
    for(LL i=0;i<n;++i){
        memcpy(dp2,dp,sizeof dp);
        memset(dp,0,sizeof dp);
        LL data;
        cin>>data;
        for(LL i=0;i<N;++i){
            if(dp2[i]){
                dp[i-data]=dp[i+data]=true;
            }
        }
    }
    LL ans=LLF;
    for(LL i=0;i<N;++i){
        if(dp[i]){
            LL data=abs(200000-i);
            if(data<ans) ans=data;
        }
    }
    cout<<ans<<endl;
}
```

- 代码实现(X)：

```
#include <bits/stdc++.h>
using namespace std;
bitset<200005> bs;
int main() {
	int n;
    cin >> n;
    int sum = 0;
    bs[0] = 1;
    for (int i = 1 ; i <= n ; i++) {
        int x;
        cin >> x;
        sum += x;
        bs = bs | (bs << x);
    }
    int ans = 0x7fffffff;
    for (int i = 0 ; i <= 200000 ; i++) {
        if (bs[i]) {
            ans = min(ans, abs(i - (sum - i)));
        }
    }
    cout << ans;
	return 0;
}
```

- [合并回文子串 (nowcoder.com)](https://ac.nowcoder.com/acm/problem/13230)
- 代码实现：

```
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
bool dp[55][55][55][55];
int main(void){
    int t;
    cin>>t;
    while(t--){
        string a,b;
        cin>>a>>b;
        int ans=0;
        string a1=' '+a,b1=' '+b;
        for(int lena=0;lena<=a.size();++lena){
            for(int lenb=0;lenb<=b.size();++lenb){
                for(int i=1,j=lena;j<=a.size();++i,++j){
                    for(int k=1,l=lenb;l<=b.size();++k,++l){
                        if(lena+lenb<2){
                            dp[i][j][k][l]=1;
                        }else{
                            dp[i][j][k][l]=0;
                            if(a1[i]==a1[j]&&lena>1){
                                if(dp[i+1][j-1][k][l]) dp[i][j][k][l]=1;
                            }
                            if(a1[i]==b1[l]&&lena&&lenb){
                                if(dp[i+1][j][k][l-1]) dp[i][j][k][l]=1;
                            }
                            if(b1[k]==b1[l]&&lenb>1){
                                if(dp[i][j][k+1][l-1]) dp[i][j][k][l]=1;
                            }
                            if(b1[k]==a1[j]&&lena&&lenb){
                                if(dp[i][j-1][k+1][l]) dp[i][j][k][l]=1;
                            }
                        }
                        if(dp[i][j][k][l]) ans=max(ans,lena+lenb);
                    }
                }
            }
        }
        cout<<ans<<endl;
    }
}

```

- 题目：[Problem - E - Codeforces](https://codeforces.com/contest/1941/problem/E)
- 代码实现：

```
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define endl '\n'
#define DB double
void solve();
int main(void){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	LL t;
	cin>>t;	
//	t=1;
	while(t--){
		solve();
	}
}
void solve(){
	LL n,m,k2,d;
	cin>>n>>m>>k2>>d;
	map<LL,LL> mp;
    vector<LL> pre(n+1);
    pre[0]=0;
	for(LL i=1;i<=n;++i){
		vector<LL> vec(m+2);
		for(LL j=1;j<=m;++j){
			cin>>vec[j];
			++vec[j];
		}
		vector<LL> dp(m+2);
		dp[1]=vec[1];
		map<LL,LL> p;
		++p[vec[1]];
		for(LL j=2;j<=m;++j){
			dp[j]=(*p.begin()).first+vec[j];
			++p[dp[j]];
			LL data=j-d-1;
			if(data>0){
				if(p[dp[data]]==1){
					p.erase(dp[data]);
				}else{
					--p[dp[data]];
				}
			}
		}
		pre[i]=pre[i-1]+dp[m];
	}
	LL ans=0x7fffffffffffffff;
	for(LL i=k2;i<=n;++i){
        ans=min(ans,pre[i]-pre[i-k2]);
    }
    cout<<ans<<endl;
}
```



## 容斥原理

- 题目：[Problem - D - Codeforces](https://codeforces.com/contest/1935/problem/D)
- 代码实现：

```
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define endl '\n'
#define DB double
void solve();
int main(void){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	LL t;
	cin>>t;
//	t=1;
	while(t--){
		solve();
	}
}
void solve(){
	LL n,c;
	cin>>n>>c;
	vector<LL> a(n);
	for(LL i=0;i<n;++i){
		cin>>a[i];
	}
	LL ans=c+1+((c+1)*c>>1);
	for(auto v:a){
		ans-=(v>>1)+1;
		ans-=c-v+1;
	}
	vector<LL> biao(2,0);
	for(auto v:a){
		++biao[v&1];
	}
	for(auto v:biao){
		ans+=(v+1)*v>>1;
	}
	cout<<ans<<endl;
}
```



## 矩阵快速幂

- 题目：[B-团圆饭_“迎新春，过大年”多校程序设计竞赛 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/73955/B)
- 代码实现：

```
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define LL long long
#define DB double
#define IOS ios::sync_with_stdio(0)
const LL INF=0x7fffffff;
const LL LLF=0x7fffffffffffffff;
const LL LLF_MID=0x7f7f7f7f7f7f7f7f;
const LL MOD=1e9+7;
struct str{
    LL data[2][2];
}juzhen={{{1,1},{1,0}}},ans={{{1,0},{0,1}}};
str jisuan(str a,str b);
LL ksm(LL n);
void solve();
int main(void){
	IOS;
	cin.tie(0);cout.tie(0);
	LL t;
// 	cin>>t;
	t=1;
	while(t--){
		solve();
	}
}
void solve(){
	LL n;
    cin>>n;
    n+=1;
    cout<<ksm(n);
}
LL ksm(LL n){
    while(n){
        if(n&1){
            ans=jisuan(ans,juzhen);
        }
        n>>=1;
        juzhen=jisuan(juzhen,juzhen);
    }
    return ans.data[0][0];
}
str jisuan(str a,str b){
    str ans;
    for(LL i=0;i<2;++i){
        for(LL j=0;j<2;++j){
            ans.data[i][j]=0;
        }
    }
    for(LL i=0;i<2;++i){
        for(LL j=0;j<2;++j){
            for(LL k=0;k<2;++k){
                ans.data[i][k]+=a.data[i][j]*b.data[j][k];
                ans.data[i][k]%=MOD;
            }
        }
    }
    return ans;
}
```



## 前缀和

- 题目：[L-贴春联_“迎新春，过大年”多校程序设计竞赛 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/73955/L)
- 代码实现：

```
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define LL long long
#define DB double
#define IOS ios::sync_with_stdio(0)
const LL INF=0x7fffffff;
const LL LLF=0x7fffffffffffffff;
const LL LLF_MID=0x7f7f7f7f7f7f7f7f;
const LL MOD=998244353;
LL d[100005],s[100005],pre[100005],hou[100005];
void solve();
int main(void){
	IOS;
	cin.tie(0);cout.tie(0);
	LL t;
// 	cin>>t;
	t=1;
	while(t--){
		solve();
	}
}
void solve(){
	LL n,k1,k2;
    cin>>n>>k1>>k2;
    for(LL i=1;i<=n;++i){
        cin>>d[i];
        s[i]=d[i]+s[i-1];
    }
    memset(pre,-0x7f,sizeof pre);
    for(LL i=k1,j=0;i<=n;++j,++i){
        pre[i]=max(pre[i-1],s[i]-s[j]);
    }
    memset(hou,-0x7f,sizeof hou);
    for(LL j=n,i=n-k1+1;i;--i,--j){
        hou[i]=max(hou[i+1],s[j]-s[i-1]);
    }
    LL ans=-LLF;
    for(LL i=k1,j=i+k2+1;j<=n-k1+1;++i,++j){
        LL data=pre[i]+hou[j]-s[j-1]+s[i];
        if(data>ans) ans=data;
    }
    cout<<ans<<endl;
}
```



## 并查集

- 题目：[H-二次元世界之寻找珂朵莉_“迎新春，过大年”多校程序设计竞赛 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/73955/H)
- 代码实现：

```
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define LL long long
#define DB double
#define IOS ios::sync_with_stdio(0)
const LL INF=0x7fffffff;
const LL LLF=0x7fffffffffffffff;
const LL LLF_MID=0x7f7f7f7f7f7f7f7f;
const LL MOD=998244353;
vector<LL> vec[100005],vec2[300005];
LL flag[100005];
bool cmp1(vector<LL> &a,vector<LL> &b){
    return a[0]<b[0];
}
bool cmp2(vector<LL> &a,vector<LL> &b){
    return a[1]<b[1];
}
bool cmp3(vector<LL> &a,vector<LL> &b){
    return a[2]<b[2];
}
LL find(LL n){
    if(flag[n]==n) return n;
    return flag[n]=find(flag[n]);
}
void solve();
int main(void){
	IOS;
	cin.tie(0);cout.tie(0);
	LL t;
// 	cin>>t;
	t=1;
	while(t--){
		solve();
	}
}
void solve(){
	LL n;
    cin>>n;
    LL a,b,c;
    for(LL i=1;i<=n;++i){
        cin>>a>>b>>c;
        vec[i]={a,b,c,i};
    }
    sort(vec+1,vec+n+1,cmp1);
    LL inde=0;
    for(LL i=2;i<=n;++i){
        vec2[++inde]={vec[i][3],vec[i-1][3],vec[i][0]-vec[i-1][0]};
    }
    sort(vec+1,vec+n+1,cmp2);
    for(LL i=2;i<=n;++i){
        vec2[++inde]={vec[i][3],vec[i-1][3],vec[i][1]-vec[i-1][1]};
    }
    sort(vec+1,vec+n+1,cmp3);
    for(LL i=2;i<=n;++i){
        vec2[++inde]={vec[i][3],vec[i-1][3],vec[i][2]-vec[i-1][2]};
    }
    sort(vec2+1,vec2+inde+1,cmp3);
    for(LL i=1;i<=n;++i){
        flag[i]=i;
    }
    LL ans=0;
    for(LL i=1;i<=inde;++i){
        LL fa=find(vec2[i][0]),fb=find(vec2[i][1]);
        if(fa==fb) continue;
        flag[fa]=fb;
        ans+=vec2[i][2];
    }
    cout<<ans<<endl;
}
```



## 枚举

- 题目：[F-放鞭炮_“迎新春，过大年”多校程序设计竞赛 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/73955/F)
- 代码实现

```
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define LL long long
#define DB double
#define IOS ios::sync_with_stdio(0)
const LL INF=0x7fffffff;
const LL LLF=0x7fffffffffffffff;
const LL LLF_MID=0x7f7f7f7f7f7f7f7f;
const LL MOD=998244353;
LL m=1;
vector<LL> vec[6];
void solve();
int main(void){
	IOS;
	cin.tie(0);cout.tie(0);
    vec[0].push_back(1);
    vec[0].push_back(4);
    vec[0].push_back(5);
    vec[1].push_back(0);
    vec[1].push_back(2);
    vec[2].push_back(1);
    vec[2].push_back(3);
    vec[2].push_back(5);
    vec[3].push_back(2);
    vec[3].push_back(4);
    vec[3].push_back(5);
    vec[4].push_back(0);
    vec[4].push_back(3);
    vec[5].push_back(0);
    vec[5].push_back(2);
    vec[5].push_back(3);
    m<<=6;
	LL t;
	cin>>t;
//	t=1;
	while(t--){
		solve();
	}
}
void solve(){
	string str1,str2;
    cin>>str1>>str2;
    LL ans=LLF;
    for(LL i=0;i<m;++i){
        LL count=0;
        string f=str1;
        for(LL j=0;j<6;++j){
            if((i>>j)&1){
                f[j]^=1;
                ++count;
                if(count==ans) break;
                for(auto v: vec[j]){
                    f[v]^=1;
                }
            }
        }
        if(f==str2&&ans>count){
            ans=count;
        }
    }
    if(ans!=LLF) cout<<ans<<endl;
    else cout<<-1<<endl;
}
```



## 二分法

- 题目：[Problem - F - Codeforces](https://codeforces.com/contest/1941/problem/F)
- 代码实现：

```
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define endl '\n'
#define DB double
void solve();
int main(void){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	LL t;
	cin>>t;	
//	t=1;
	while(t--){
		solve();
	}
}
void solve(){
	LL n,m,k;
	cin>>n>>m>>k;
	vector<LL> a(n),d(m),f(k);
	for(LL i=0;i<n;++i){
		cin>>a[i];
	}
	for(LL i=0;i<m;++i){
		cin>>d[i];
	}
	for(LL i=0;i<k;++i){
		cin>>f[i];
	}
	sort(a.begin(),a.end());
	vector<LL> c(n+1);
	for(LL i=1;i<n;++i){
		c[i]=a[i]-a[i-1];
	}
	sort(c.begin()+1,c.end(),greater<LL>());
	LL x,y;
	for(LL i=1;i<n;++i){
		if(a[i]-a[i-1]==c[1]){
			x=a[i-1];
			y=a[i];
			break;
		}
	}
	sort(d.begin(),d.end());
	sort(f.begin(),f.end());
	LL l=max(c[1]+1>>1,c[2]),r=c[1];
	while(l<r){
		LL mid=l+r>>1;
		bool flag=false;
		for(auto v:d){
			LL nx=y-mid,ny=x+mid;
			auto p=lower_bound(f.begin(),f.end(),nx-v);
			if(p!=f.end()&&*p<=ny-v){
				flag=true;
				break;
			}
		}
		if(flag){
			r=mid;
		}else{
			l=mid+1;
		}
	}
	cout<<l<<endl;
}
```



## 树状数组

- 题目：[F-数对_西安理工大学2024年程序设计校赛（校外同步赛） (nowcoder.com)](https://ac.nowcoder.com/acm/contest/73778/F)
- 代码实现：

```
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define endl '\n'
#define DB double
const LL N=1000000;
LL tree[N+5],d[N+5];
LL n,q,m;
LL lowbit(LL x){
    return x&-x;
}
LL query(LL pos){
    LL ans=0; 
    for(LL i=pos;i;i-=lowbit(i)){
        ans+=tree[i];
    }
    return ans;
}
void update(LL pos,LL data){
    for(LL i=pos;i<=N;i+=lowbit(i)){
        tree[i]+=data;
    }
}
void solve();
int main(void){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	LL t;
// 	cin>>t;	
	t=1;
	while(t--){
		solve();
	}
}
void solve(){
    cin>>n>>q>>m;
    LL ans=0;
    for(LL i=1;i<=n;++i){
        cin>>d[i];
        update(d[i],1);
        ans+=query(m/d[i]);
    }
    for(LL i=1;i<=q;++i){
        LL op;
        cin>>op;
        if(op==1){
            LL pos,data;
            cin>>pos>>data;
            ans-=query(m/d[pos]);
            update(d[pos],-1);
            d[pos]=data;
            update(d[pos],1);
            ans+=query(m/d[pos]);
        }else{
            cout<<ans<<endl;
        }
    }
}
```



## BFS

- 题目：[J-矩阵最大路径与_广州大学第十八届ACM大学生程序设计竞赛（同步赛） (nowcoder.com)](https://ac.nowcoder.com/acm/contest/77448/J)
- 代码实现：

```
#include <bits/stdc++.h>
using namespace std;
const int dx[] = {0, 0, 1, -1};
const int dy[] = {1, -1, 0, 0};
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n, m;
	cin >> n >> m;
	vector a(n + 1, vector(m + 1, 0));
	for (int i = 1 ; i <= n ; i++) {
		for (int j = 1 ; j <= m ; j++) {
			cin >> a[i][j];
		}
	}
	for (int i = 1 ; i <= n ; i++) {
		for (int j = 1 ; j <= m ; j++) {
			a[i][j] &= a[1][1];
			a[i][j] &= a[n][m];
		}
	}
	int ans = 0;
	for (int k = 30 ; k >= 0 ; k--) {
		vector g(n + 1, vector(m + 1, 0));
		for (int i = 1 ; i <= n ; i++) {
			for (int j = 1 ; j <= m ; j++) {
				if (a[i][j] & 1 << k) {
					g[i][j] = true;
				}
			}
		}
		vector vis(n + 1, vector(m + 1, false));
		queue<pair<int, int>> que;
		que.emplace(1, 1);
		vis[1][1] = true;
		while (!que.empty()) {
			auto [x, y] = que.front();
			que.pop();
			for (int i = 0 ; i < 4 ; i++) {
				int xx = x + dx[i], yy = y + dy[i];
				if (xx < 1 || xx > n || yy < 1 || yy > m) continue;
				if (vis[xx][yy]) continue;
				if (!g[xx][yy]) continue;
				vis[xx][yy] = true;
				que.emplace(xx, yy);
			}
		} 
		if (vis[n][m]) {
			ans |= 1 << k;
			for (int i = 1 ; i <= n ; i++) {
				for (int j = 1 ; j <= m ; j++) {
					if (a[i][j] & 1 << k) {
						
					} else {
						a[i][j] = 0;
					}
				}
			}
		}
	}
	cout << ans;
	return 0;
}
```

- 题目：[HunanCPC 2015 - Virtual Judge (vjudge.net)](https://vjudge.net/contest/618187#problem/E)
- 代码实现：

```
#include<bitsdc++.h>
using namespace std;
#define LL long long
#define endl '\n'
#define DB double	
const LL MOD=0x7fffffffffffffff;
struct str{
	LL x,y,d,w;
	bool operator<(const str b)const{
		return w>b.w;
	}
};
struct str2{
	LL x,y,w;
	bool operator<(const str2 b)const{
		return w>b.w;
	}
};
LL dir[4][2]={{-1,0},{0,-1},{1,0},{0,1}};
void solve();
int main(void){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
//	LL t=1;
//	cin>>t;
	LL n,m,x1,y1,x2,y2;
	LL b=1;
	while(cin>>n){
		cin>>m>>x1>>y1>>x2>>y2;
		vector<vector<LL>> d(n+1,vector<LL>(m+1,0));
		cout<<"Case "<<b<<": ";
		++b;
		for(LL i=1;i<=n;++i){
			for(LL j=1;j<=m;++j){
				char str[5];
				cin>>str;
				if(str[0]=='*'){
					d[i][j]=MOD;
				}else{
					sscanf(str,"%lld",&d[i][j]);
				}
			}
		}
		if(x1==x2&&y1==y2){
			cout<<d[x1][y1]<<" "<<d[x2][y2]<<endl;
			continue;
		}
		vector<vector<LL>> flag2(n+1,vector<LL>(m+1,MOD));
		priority_queue<str2> que2;
		que2.push({x1,y1,d[x1][y1]});
		flag2[x1][y1]=d[x1][y1];
		LL ans2=MOD;
		while(que2.size()){
			str2 p=que2.top();
			que2.pop();
			for(LL i=0;i<4;++i){
				LL nx=p.x+dir[i][0],ny=p.y+dir[i][1];
				if(nx<1||nx>n||ny<1||ny>m||d[nx][ny]==MOD) continue;
				LL data=p.w+d[nx][ny];
				if(flag2[nx][ny]<=data||data>=ans2) continue;
				flag2[nx][ny]=data;
				que2.push({nx,ny,data});
				if(nx==x2&&ny==y2&&data<ans2){
					ans2=data;
				}
			}
		}
		if(ans2==MOD){
			cout<<-1<<" "<<-1<<endl;
			continue;
		}else cout<<ans2<<" ";
		priority_queue<str> que;
		que.push({x1,y1,-1,d[x1][y1]});
		LL ans=MOD;
		vector<vector<vector<LL>>> flag(n+1,vector<vector<LL>>(m+1,vector<LL>(4,MOD)));
		while(que.size()){
			str p=que.top();
			que.pop();
			for(LL i=0;i<4;++i){
				if(p.d==i) continue;
				LL nx=p.x+dir[i][0],ny=p.y+dir[i][1];
				if(nx<1||nx>n||ny<1||ny>m||d[nx][ny]==MOD) continue;
				LL data=p.w+d[nx][ny];
				if(flag[nx][ny][i]<=data||data>=ans) continue;
				flag[nx][ny][i]=data;
				que.push({nx,ny,i,data});
				if(nx==x2&&ny==y2&&data<ans){
					ans=data;
				}
			}
		}
		if(ans==MOD) cout<<-1<<endl;
		else cout<<ans<<endl;
	}
}
```

- 题目：[F-强化学习 Is All You Need_“崖山数据库杯”深圳大学程序设计竞赛（正式赛） (nowcoder.com)](https://ac.nowcoder.com/acm/contest/79000/F)
- 代码实现：

```
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define endl '\n'
#define DB double
const LL LLF=0x7fffffffffffffff;
LL ans[1002],a[1002][1002],b[1002][1002];
bool flag[1002];
LL n,m;
LL read();
void solve();
int main(void){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	LL t=1;
	while(t--){
		solve();
	}
}
void solve(){
    n=read();
    m=read();
    for(LL i=1;i<=n;++i){
        for(LL j=1;j<=m;++j){
            a[i][j]=read();
        }
    }
    for(LL i=1;i<=n;++i){
        for(LL j=1;j<=m;++j){
            b[i][j]=read();
        }
    }
    for(LL i=1;i<=n+1;++i){
        ans[i]=-LLF;
    }
    queue<LL> que;
    que.push(1);
    ans[1]=0;
    flag[1]=true;
    while(que.size()){
        LL p=que.front();
        que.pop();
        flag[p]=false;
        for(LL i=1;i<=m;++i){
            LL val=ans[p]+a[p][i];
            if(val<=ans[b[p][i]]) continue;
            ans[b[p][i]]=val;
            if(b[p][i]==n+1) continue;
            if(!flag[b[p][i]]){
                flag[b[p][i]]=true;
                que.push(b[p][i]);
            }
        }
    }
    cout<<ans[n+1]<<endl;
}
LL read(){
    LL ans=0;
    char ch=getchar();
    LL f=1;
    while(ch<'0'||ch>'9'){
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        ans=(ans<<3)+(ans<<1)+(ch^'0');
        ch=getchar();
    }
    return ans*f;
}
```



# 算法综合

## 二分哈希

- [I-字串比较_第十一届"图灵杯"NEUQ-ACM程序设计竞赛 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/76681/I)
- 代码实现(X)：

```
#include <bits/stdc++.h>
using namespace std;

const long long mod = 1000000007;

long long hash1[200005], hash2[200005], base[200005];
long long get1(int L, int R) {
    if (L > R) return 0;
    return (hash1[R] - hash1[L - 1] * base[R - L + 1] % mod + mod) % mod;
}
long long get2(int L, int R) {
    if (L > R) return 0;
    return (hash2[R] - hash2[L - 1] * base[R - L + 1] % mod + mod) % mod;
}
int main() {
    base[0] = 1;
    base[1] = 23333;
    for (int i = 2 ; i < 200005 ; i++) {
        base[i] = base[i - 1] * base[1] % mod;
    }
	int n, m, q;
    cin >> n >> m >> q;
    string s1, s2;
    cin >> s1 >> s2;
    s1 = " " + s1;
    s2 = " " + s2;
    for (int i = 1 ; i <= n ; i++) {
        hash1[i] = (hash1[i - 1] * base[1] + s1[i]) % mod;
    }
    for (int i = 1 ; i <= m ; i++) {
        hash2[i] = (hash2[i - 1] * base[1] + s2[i]) % mod;
    }
    while (q--) {
        int L1, R1, L2, R2;
        cin >> L1 >> R1 >> L2 >> R2;
        if (s1[L1] < s2[L2]) {
            cout << "<\n";
            continue;
        } else if (s1[L1] > s2[L2]) {
            cout << ">\n";
            continue;
        } else if (get1(L1, R1) == get2(L2, R2)) {
            cout << "=\n";
            continue;
        }
        int L = 1, R = R1 - L1 + 1;
        while (L < R) {
            int mid = L + R + 1 >> 1;
            if (get1(L1, L1 + mid - 1) == get2(L2, L2 + mid - 1)) {
                L = mid;
            } else {
                R = mid - 1;
            }
        }
        if (s1[L1 + L] == s2[L2 + L]) {
            cout << "=\n";
        } else if (s1[L1 + L] < s2[L2 + L]) {
            cout << "<\n";
        } else {
            cout << ">\n";
        }
    }
	return 0;
}
```

